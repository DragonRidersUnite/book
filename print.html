<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Games with DragonRuby</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A comprehensive guide to shipping cross-platform 2D games with ease using DragonRuby Game Toolkit.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="01-hello-dragon.html"><strong aria-hidden="true">1.</strong> Hello Dragon!</a></li><li class="chapter-item expanded "><a href="02-player-movement.html"><strong aria-hidden="true">2.</strong> Player Movement</a></li><li class="chapter-item expanded "><a href="03-spit-fire.html"><strong aria-hidden="true">3.</strong> Spit Fire</a></li><li class="chapter-item expanded "><a href="04-target-practice.html"><strong aria-hidden="true">4.</strong> Target Practice</a></li><li class="chapter-item expanded "><a href="05-fireball-clean-up.html"><strong aria-hidden="true">5.</strong> Fireball Clean Up</a></li><li class="chapter-item expanded "><a href="06-time-attack.html"><strong aria-hidden="true">6.</strong> Time Attack</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> High-Score</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Sound</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Animation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Background</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Scenes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Ship Your Game</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> What Next</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><div>Ruby Primer</div></li><li class="chapter-item expanded affix "><a href="source-control.html">Source Control</a></li><li class="chapter-item expanded affix "><div>Beyond the Code</div></li><li class="chapter-item expanded affix "><a href="game-dev-resources.html">Game Dev Resources</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Building Games with DragonRuby</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/DragonRidersUnite/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="./img/cover.jpg" alt="cover of Building Games with DragonRuby, with the subtitle 'A comprehensive guide to shipping cross-platform games with ease' by Brett Chalupa and the Dragon Rider Community." /></p>
<p>üöß <em>Building Games with DragonRuby</em> is a work in progress. Expect typos, issues, and incompleteness. üöß</p>
<p>This book is aimed at new game developers who are interested in learning to code and build games. If you've written code before, especially Ruby, then you'll have a bit of a headstart. But the concepts in this book are beginner friendly. Whether you're new to game dev or just DragonRuby Game Toolkit, you'll have made a finished game by the end of this.</p>
<p>You need no prior experience with programming or game making to follow this book.</p>
<h2 id="why-learn-how-to-make-games"><a class="header" href="#why-learn-how-to-make-games">Why Learn How to Make Games</a></h2>
<p>Making games is a total blast. It's challenging but rewarding. They're the sum total of so many creative mediums, <em>plus</em> they're interactive. You'll learn so many different skills by making games:</p>
<ul>
<li>Programming and logic</li>
<li>Rendering images</li>
<li>Responding to input</li>
<li>Game design</li>
<li>Interactive design</li>
<li>Working with image files</li>
<li>Editing audio files</li>
<li>Distributing the game software to users</li>
<li>Getting feedback from your game and iterating</li>
</ul>
<h2 id="about-dragonruby-game-toolkit"><a class="header" href="#about-dragonruby-game-toolkit">About DragonRuby Game Toolkit</a></h2>
<p><a href="https://dragonruby.org/toolkit/game">DragonRuby Game Toolkit</a> (DRGTK) is a cross-platform game engine for building 2D games. It lets you write games in Ruby, a wonderfully expressive and approachable language. It allows game developers to quickly iterate on their games and ship them to any modern platform.</p>
<p>DRGTK is <strong>not</strong> a no-code engine. You'll write the code that your game runs. This may seem scary at first, but it's a lot of fun and really powerful. Making games is also a great way to learn how to code! Don't know Ruby? That's okay, this book will teach you what you need to know.</p>
<h3 id="but-it-isnt-free"><a class="header" href="#but-it-isnt-free">But it isn't free!</a></h3>
<p>DRGTK costs money, yes. And there are plenty of free game engines out there. But the DRGTK team is committed to sustainably working on the engine and making it the best it can be, which means they need to get paid for their work. Support small teams by buying their software, it shows you're interested and it helps them keep doing what they love.</p>
<p>You're investing in the engine and ecosystem, quite literally, by buying DRGTK. I want to see it succeed, so I bought a license. I want to see it succeed so badly I've written this book to try to help <em>you</em> make games with it.</p>
<p>Plus, if you're a student or in need of financial assistance, the DragonRuby team offers free licenses. <a href="https://dragonruby.org/toolkit/game">Get in touch with the team to get a free license.</a></p>
<p>There's also <a href="fiddle.dragonruby.org">a free, interactive environment</a> you can use to sample DragonRuby GTK. Give it a try and see what you think!</p>
<h2 id="why-dragonruby-toolkit"><a class="header" href="#why-dragonruby-toolkit">Why DragonRuby Toolkit</a></h2>
<p>There are more game engines, frameworks, and libraries than I can count on my hands and toes. So why should you use DragonRuby?</p>
<p>That's a legit question. Here are my reasons why:</p>
<ul>
<li>It's focused on 2D games, so there's no competing interests in how the tooling works. It means what you need to know is pretty simple and easy to remember.</li>
<li>It allows building games for all modern platforms, from desktop computers to the web to mobile devices to consoles. It's truly cross-platform and <em>just works</em>, which is amazing.</li>
<li>It's fast a heck, which is important for making quality games.</li>
<li>It makes use of Ruby, which is a wonderfully productive programming language.</li>
<li>It doesn't force you to use a specific editor or tooling.</li>
<li>It's lightweight to run the engine, which is great. Everything runs fast.</li>
<li>It has live-reload and no compile times, which means when you change your game code, it automatically refreshes in the running engine. This is honestly so amazing, that you wouldn't know it unless you've used other game engines that require you to start a new build with each change.</li>
</ul>
<p>I'm going to be honest, DRGTK might not be for you. If you want to make 3D games, look elsewhere. Although, if you're new to game development, I wouldn't recommend starting with a 3D game. If you're absolutely not willing to try coding, look elsewhere.</p>
<p>But for everyone else, I think DRGTK will knock your socks off (or at least shift them down a little).</p>
<h2 id="mindset"><a class="header" href="#mindset">Mindset</a></h2>
<p>When learning something new, especially something that's challenging, it's important to have the right mindset.</p>
<ul>
<li>Be curious: it's the best way to learn!</li>
<li>Be patient: learning is difficult, but stick with it</li>
<li>Be kind: to yourself and others</li>
</ul>
<p>When we learn how to play a new instrument, we learn the basics by covering simplistic pieces of music. Similarly, we're going to &quot;cover&quot; simpler game mechanics to get you started. Before long, you'll grasp the basics and be able to move onto more complex games and mechanics.</p>
<p>Start by making small games that you can finish in a couple of days. Make a lot of small games to learn quickly. Don't get too wrapped up in your dream idea or making something that gets on Steam. Definitely don't try to make an MMORPG. Instead, focus on <strong>shipping</strong> your small games.</p>
<p>What's shipping? Isn't that when you want Mulder and Scully to kiss? No! Get your head out of the gutter you alien-loving freak. (I want to believe! üõ∏) Shipping is when you 1. finish your game and 2. release it for people to play it.</p>
<p>So here's your mindset, really, boiled down: make a small game and ship it for free, then make another small game and ship it for free. Before long, you'll be building a visual novel where Mulder and Scully kiss and be swimming in a pool of cryptocoins! But seriously, what that mindset will do is help you grow as a developer, build an audience, and get your shipping muscle primed and ready for making a better game with each one.</p>
<h2 id="what-well-be-making"><a class="header" href="#what-well-be-making">What We'll Be Making</a></h2>
<p>Throughout the book, we'll be building a simple shoot-'em-up where you pilot a dragon. You'll learn all of the foundation aspects of making a game:</p>
<ul>
<li>The game loop</li>
<li>Rendering text</li>
<li>Rendering sprites and animating them</li>
<li>Handling input</li>
<li>Enemies and AI</li>
<li>Playing sound effects and music</li>
<li>Polishing your game</li>
<li>Shipping it!</li>
</ul>
<p>TODO: playable demo link</p>
<h2 id="hold-the-gosh-dang-phone"><a class="header" href="#hold-the-gosh-dang-phone">Hold the Gosh Dang Phone</a></h2>
<p>&quot;Who the heck are <em>you</em>?&quot; you might be shouting at your screen. Little ole me? I'm just the voice of the dragon that lives within all beings! No, no, I kid. I'm Brett! I'm a programmer who enjoys making games and sharing what I've learned along the way.</p>
<p><img src="./img/brett.png" alt="pixel avatar of Brett" /></p>
<p>That's-a-me! If I was a bunch of pixels I guess.</p>
<p>I love Ruby. I've been writing it for over 12 years, and it's such a joy. I also love games. Particularly 2D games. So here we are. ‚ù§Ô∏èüíé + üéÆ = üìï How's that for an equation?!</p>
<p>I don't know, you want me to be serious about why you should listen to me? Oh you skipped this section, okay fine. Wow, did you drop that banana peel there? You trying to take me out already? This early in the book? Well, I'll see you in the next chapter! We'll see who gets the last laugh.</p>
<h2 id="why-the-book-is-free"><a class="header" href="#why-the-book-is-free">Why the Book is Free</a></h2>
<p>When I was 16, I took a computer science class in high school. It was my first exposure to programming with a language more complex than HTML and CSS. We programmed in Java. My teacher had us print out our assignments for grading (for some odd reason).</p>
<p>That class was foundational in the course my life would take in the 14 years since. At age 16 I was an emo kid who loved video games. Imagine a swoopy haired teen in their bedroom listening to Bright Eyes while playing <em>Final Fantasy XII</em>. That was me.</p>
<p>So naturally, for my final project in that high school computer science class I made a game. You pilot a Moltres from Pokemon who shots fire balls at Zaku mechs from Gundam that fly across the screen. If you get hit by an enemy, it's game over. If you defeat all of the enemies, you win. This game was lovingly titled <em>Zaku Space Battle</em>.</p>
<p><img src="./img/zaku-space-battle.jpg" alt="screenshot of Zaku Space Battle showing the Moltres sprite, Zaku sprites, fire ball, and space background" /></p>
<p>In order to make that game, I followed a free online tutorial that laid out the foundations of making a game with Java. There was no way I would have figured out on my own how to make a game at that point without help from a free online tutorial. I had <em>so</em> much fun making that final project that I went to college to study game programming and do programming for my career. I took what I learned in that tutorial, expanded the functionality, and made it my own (with copyright sprites, but still!).</p>
<p>This book is freely accessible so that someone who loves games and wants to try making them can do so. Free programming resources have truly shaped my life and career. I wouldn't have the life and career I have now without them. So I want to give back and try to help other aspiring developers.</p>
<p>You'll learn the foundations of game programming and making games, as well as some more advanced topics. If this book can help even just one person start and finish a game, it's worth every minute I've spent on it. We'll make a game not too dissimilar from <em>Zaku Space Battle</em>. Once you finish it, take what you've learned and make it your own!</p>
<h2 id="contribute"><a class="header" href="#contribute">Contribute</a></h2>
<p>This book is open source. That means anyone can view the code that builds it and contribute toward making better. Did you find something that doesn't work, a typo, or lacks clarity? <a href="https://github.com/DragonRidersUnite/book">Submit an issue or contribute on GitHub.</a> It's easy and you can do it right from your browser. Thanks in advance!</p>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<p>All right, are you ready to make a game? Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-dragon"><a class="header" href="#hello-dragon">Hello Dragon!</a></h1>
<p>We'll start by rendering an image and some simple text on the screen. But first, we need to get our computer and DragonRuby Game Toolkit ready for developing.</p>
<h2 id="first-steps"><a class="header" href="#first-steps">First Steps</a></h2>
<ol>
<li><strong>Download a code editor:</strong> Since you'll be coding your game, you need a special text editor to let you write the code without any extra formatting that text editors like Microsoft Word add. <a href="https://code.visualstudio.com/">Visual Studio Code</a> is a great free editor. Download and install it. (Or use your own favorite editor.)</li>
<li><strong>Get DragonRuby GTK:</strong> You need to get a copy of DragonRuby GTK so you can use the engine. <a href="https://dragonruby.itch.io/dragonruby-gtk/purchase">Buy it on Itch and download the zip file for your operating system.</a></li>
<li><strong>Extract the DRGTK engine zip</strong>: In your computer's file explorer, extract the engine zip file.</li>
</ol>
<p>You're ready to work on your game. Let's get to it!</p>
<p><strong>ProTip:</strong> don't delete the zip file! You can unzip it again for when you start working on your next game. It's helpful to keep it around.</p>
<h2 id="whats-in-the-engine-zip"><a class="header" href="#whats-in-the-engine-zip">What's in the Engine Zip</a></h2>
<p>When you download DragonRuby Game Toolkit, it contains everything you need to build your game. There's no external dependencies to install or monkey with. You just use the provided files and start making your game.</p>
<p>Let's go over the key files in the archive you just extracted:</p>
<ul>
<li><code>dragonruby</code> ‚Äî the executable you'll run to launch your game in development mode, you're primary entry into the development flow</li>
<li><code>dragonruby-publish</code> ‚Äî a command-line tool to help you easily build and publish your game online, don't worry about this yet!</li>
<li><code>samples/</code> ‚Äî a folder of example code that you can run if you'd like, or just ignore it for now</li>
<li><code>docs/</code> ‚Äî the DragonRuby Game Toolkit docs for the version you've downloaded, extremely handy if you want to dive deeper than this book</li>
<li><code>mygame/</code> üåü ‚Äî as the name implies, this is where the code, graphics, sound, and other assets live for your game; this is the primary folder you'll be working in
<ul>
<li><code>app/</code> ‚Äî this is where your Ruby code goes
<ul>
<li><code>main.rb</code> ‚Äî this is the main file for your game code, don't worry about the other two yet</li>
</ul>
</li>
<li><code>data/</code> ‚Äî where you can put any data for your game, like level editor files</li>
<li><code>fonts/</code> ‚Äî where fonts go, duh!</li>
<li><code>metadata/</code> ‚Äî configuration files for your game, we'll do more here later</li>
<li><code>sounds/</code> ‚Äî where music and sound effects go</li>
<li><code>sprites/</code> ‚Äî where images go that will be rendered in the game; there are already some simple ones to work with by default</li>
</ul>
</li>
</ul>
<p>Don't worry about the other files yet. Focus on the <code>mygame/</code> directory, and, specifically, <code>mygame/app/main.rb</code>.</p>
<h2 id="start-the-game"><a class="header" href="#start-the-game">Start the Game</a></h2>
<p>Launch the <code>dragonruby</code> file.</p>
<p>If you're on MacOS, right-click the file and select &quot;Open&quot;. You'll need to ensure software from unverified sources can be installed.</p>
<p>Here's what gets displayed:</p>
<p><img src="./img/hello-world.jpg" alt="screenshot of the Hello World! for DragonRuby GTK" /></p>
<p>This isn't a game... yet! But it is doing three key things:</p>
<ol>
<li>Launching an app window</li>
<li>Rendering text</li>
<li>Displaying an image</li>
</ol>
<p>And you haven't even written any code yet. Not a bad starting place.</p>
<p>DRGTK handles the unfun stuff of making games‚Äîdealing with low-level APIs like graphics, window, and sounds. We can instead focus on making our game.</p>
<h2 id="an-overview-of-the-main-game-file"><a class="header" href="#an-overview-of-the-main-game-file">An Overview of the Main Game File</a></h2>
<p>Let's take a look at what's in <code>mygame/app/main.rb</code>:</p>
<pre><code class="language-ruby">def tick args
  args.outputs.labels  &lt;&lt; [640, 500, 'Hello World!', 5, 1]
  args.outputs.labels  &lt;&lt; [640, 460, 'Go to docs/docs.html and read it!', 5, 1]
  args.outputs.labels  &lt;&lt; [640, 420, 'Join the Discord! https://discord.dragonruby.org', 5, 1]
  args.outputs.sprites &lt;&lt; [576, 280, 128, 101, 'dragonruby.png']
end
</code></pre>
<p>You can open this file yourself in Visual Studio Code. Go ahead and do that: New Window &gt; Open &gt; [select the folder on your computer with the engine in it]</p>
<p>Six lines of codes to render text and an image? Not bad! (Trust me, if you did this all from scratch without an engine, it'd take at least hundreds of lines of code.)</p>
<p>Here's what that code does, line by line:</p>
<pre><code class="language-ruby">def tick args
</code></pre>
<p>This <code>def</code>ines a method called <code>tick</code> and passes in an argument called <code>args</code>. Methods are reusable pieces of code that you can call to do something over and over again. Think of methods like verbs; they're actions. Methods are a foundational building block of code that allow for code reuse.</p>
<p>Let's say you wanted to give a friend a cookie üç™, you'd define a method called <code>give_cookie</code> and pass in the <code>friend</code> as a parameter.</p>
<pre><code class="language-ruby">def give_cookie(friend)
  friend.eat(:cookie)
end
</code></pre>
<p>You'd then call that method like:</p>
<pre><code class="language-ruby">francis = Friend.new
give_cookie(francis)
</code></pre>
<p>Wait, how'd we get talking about cookies and friends? Okay, back to the code above.</p>
<p><code>args</code> is a bunch of data that gets passed into <code>tick</code> whenver it is called. We'll learn more about <code>args</code> soon.</p>
<p>The next three lines handle outputting text to the screen:</p>
<pre><code class="language-ruby">args.outputs.labels  &lt;&lt; [640, 500, 'Hello World!', 5, 1]
args.outputs.labels  &lt;&lt; [640, 460, 'Go to docs/docs.html and read it!', 5, 1]
args.outputs.labels  &lt;&lt; [640, 420, 'Join the Discord! https://discord.dragonruby.org', 5, 1]
</code></pre>
<p>Your eyes might be melting a little bit. But don't worry, wipe that melted bit of eye away and focus! It's actually pretty intuitive once you get the hang of it.</p>
<p>Remember <code>args</code> from above? That parameter that's passed into <code>tick</code>? Well, you can call methods on it! This allows you to interact with the game engine.</p>
<p><code>args</code> has a method called <code>outputs</code> that represents the data that gets rendered in the screen. You access it with <code>args.outputs</code>. Neato! <code>labels</code> is a method on <code>outputs</code>, see how the <code>.</code> chains things together?</p>
<p>The <code>&lt;&lt;</code> is called the shovel operator. It lets you push data into a collection. <code>labels</code> is the collection we're shoveling data into because we want to render some text.</p>
<p>And then finally the code within the brackets <code>[]</code> is an array of data that represents what we want to display on the screen. It may not be clear exactly what it's doing yet, but it'll become more clear over time.</p>
<p>[TODO: array illustration]</p>
<p>You can see some code in quotes, those are strings. And they're what's being displayed by the game. In order to show the text, though, we need to tell the engine where to place it on the screen. That's what the first two elements of the array do: they specify the x and y position in of the text in the game. Then there's the text we want to render. That's followed by the size. Then finally the alignment (centered in this case).</p>
<p>Here's it broken down:</p>
<pre><code class="language-ruby">#  x,   y,           text, size, alignment
[640, 500, 'Hello World!',    5,         1]
</code></pre>
<p>Don't worry about memorizing what the positional elements of the array mean. This is just a quick way to render text. We'll start using a more friendly approach soon enough. The sample game does this three times, thus rendering three difference pieces of text. The <code>y</code> coordinate is different for each, stacking them on top of each other vertically instead of overlapping one another.</p>
<p>Gosh enough of this rambling, let's adjust some code. Change the text from <code>&quot;Hello World!&quot;</code> to be <code>&quot;Hello Dragon!&quot;</code> and save the file.</p>
<p><img src="./img/hello-dragon.jpg" alt="screenshot of the Hello Dragon! for DragonRuby GTK" /></p>
<p>Did you see that? The game reloaded your code and changed the text to be &quot;Hello Dragon!&quot; That was quick, wasn't it? That's one of the best parts of DRGTK‚Äîlive reloading of your game code in the engine. This allows you to make changes to your game quickly, reducing the time between the cycles of writing your code and testing it.</p>
<pre><code class="language-ruby">args.outputs.sprites &lt;&lt; [576, 280, 128, 101, 'dragonruby.png']
</code></pre>
<p><code>args.outputs.sprites</code> is like labels, but it's instead a collection for sprites. It renders the <code>&quot;dragonruby.png&quot;</code> image at x: 576, y: 280, just like label text, but it also sets the size of the image to display. That's what the <code>128</code> and <code>101</code> represent in the array. Here's a break down of those elements:</p>
<pre><code class="language-ruby">#  x,   y,   w,   h,            image
[576, 280, 128, 101, 'dragonruby.png']
</code></pre>
<p>Just like with labels, don't worry about memorizing the order here. There are friendlier ways to display them that we'll get to shortly.</p>
<p>But it's an easy enough bit of code for putting an image on the screen.</p>
<p>Finally, the last line:</p>
<pre><code class="language-ruby">end
</code></pre>
<p>signifies that the definition of the <code>tick</code> method is over. Any code after that isn't part of the <code>tick</code> method. That's it for what we get out of the box.</p>
<h2 id="screen-coordinates-explained"><a class="header" href="#screen-coordinates-explained">Screen Coordinates Explained</a></h2>
<p>Let's take a detour down Screen Coordinates Road. The <code>x</code> and <code>y</code> position are coordinates on the two-dimensional plane of the game window. Remember geometry? I barely do. But this is important, so don't doze off on me yet, we're only in the first chapter still!</p>
<p>[TODO: coordinates illustration]</p>
<p>DRGTK games are made up of a window that's 1280x720 pixels large. That's 1280 pixels wide and 720 pixels tall. The rectangle of the game screen is 921600 pixels, that's those two numbers multiplied. Each of those pixels has a coordinate on the plane. It makes it easy to refer to a specific pixel by using its <code>x</code> and <code>y</code> position.</p>
<p>DRGTK starts 0, 0 in the lower left. So 1280, 720 would be the upper right. <strong>Note:</strong> this varies from most game engines and libraries and tools, but it's intentional to make it easier to think about gravity and the geometric 2D plane that is taught in mathematics.</p>
<p>It's important to keep coordinates in mind, as we'll be using them a lot when making our game. A major aspect of games is moving things on the screen, which we do by changing their coordinates on the plane.</p>
<h2 id="our-own-hello"><a class="header" href="#our-own-hello">Our Own Hello</a></h2>
<p>Back to making the game. Okay, yeah, you changed a string and it changed what was rendered. That's neat. But let's bump it up a notch.</p>
<p>I want you to delete the code in <code>mygame/app/main.rb</code>. Select it all and delete it. Yup, I know, the blank canvas is a challenge. But you need to start writing the code yourself in order to learn and build the muscle memory. So go ahead and type out each line below into your <code>main.rb</code>.</p>
<p>[TODO: hand-write it, don't copy it illustration]</p>
<pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; [120, 120, &quot;Hello Dragon!&quot;]
end
</code></pre>
<p>You know what that does, right? Well you saw it automatically reload in your game, so of course you do!</p>
<p>Let's greet our friend Oboe too.</p>
<pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; [120, 120, &quot;Hello Dragon!&quot;]
  args.outputs.labels &lt;&lt; [120, 100, &quot;Hello Oboe!&quot;]
end
</code></pre>
<p>Wow, so many friends we're saying hello to! The thing is... that code is a bit... duplicative. Let's write our own method to clean that up:</p>
<pre><code class="language-ruby">def greet friend
  &quot;Hello #{friend}!&quot;
end

def tick args
  args.outputs.labels &lt;&lt; [120, 120, greet(&quot;Dragon&quot;)]
  args.outputs.labels &lt;&lt; [120, 100, greet(&quot;Oboe&quot;)]
end
</code></pre>
<p>The new code refactors (changes the implementation of the code without changing the behavior) the original so that we can easily change the greeting in one place instead of many. This is a bit of a trivial example, but it shows how we can write our own methods in DRGTK to make our code better. Reusing code is foundational for the rest of this book.</p>
<p>The <code>&quot;Hello #{friend}!&quot;</code> code does what's called string interpolation. It takes whatever <code>friend</code> is, hopefully a name as a string, and inserts it. It's pretty similar to this code: <code>&quot;Hello &quot; + friend + &quot;!&quot;</code>, but quite a bit friendlier to use. The <code>#{}</code> tells Ruby to run any Ruby code within those curly braces.</p>
<p>Methods in Ruby return a value. Return values can then be used by the caller for whatever purposes are needed. In the example above, the return value is the string we build. Ruby returns the last line of the method definition automatically. But you can explicitly return early with <code>return</code>, which can be useful if you want to end the execution of a method early.</p>
<p>Go ahead and change the <code>#greet</code> method to:</p>
<pre><code class="language-ruby">def greet friend
  &quot;Hello #{friend}!&quot;
  1
end
</code></pre>
<p>Whoa! What happened to our greetings? Well, we changed our code and it now always returns <code>1</code>, which isn't what we want. It's just an example to illustrate how that works. Go ahead and undo that change.</p>
<p>Let's do one final thing in our hand-crafted, artisinal version of rendering text and images. Let's display a sprite. In <code>mygame/sprites/misc/</code> there's a file named <code>dragon-0.png</code>. It's a pixel art dragon made by Nick Culbertson that's free to use. Pretty neat!</p>
<pre><code class="language-ruby">def greet friend
  &quot;Hello #{friend}!&quot;
end

def tick args
  args.outputs.labels &lt;&lt; [120, 120, greet(&quot;Dragon&quot;)]
  args.outputs.labels &lt;&lt; [120, 100, greet(&quot;Oboe&quot;)]
  # Here's our new line
  args.outputs.sprites &lt;&lt; [120, 280, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p><img src="./img/hello-dragon-own.jpg" alt="screenshot of the Hello Dragon! with pixel dragon displayed" /></p>
<p>That's some pretty fine code for the first chapter. We've got text and an image displaying. We learned about methods too. Don't worry if it's not all making total and complete sense. You'll understand more with time. Remember, be patient.</p>
<h2 id="game-loop-explained"><a class="header" href="#game-loop-explained">Game Loop Explained</a></h2>
<p>There's a lot of magic happening where we can just write <code>def tick</code> and magically have a game. What's happening here is that DragonRuby Game Toolkit takes the code in <code>mygame/app/main.rb</code>, find the tick method, and then runs a loop that calls it 60 times every second until the program closes. This loop is referred to as the Game Loop.</p>
<p>When programming games, any number of things are happening at one time. Enemies are moving, images are being displayed, math is being calculated, input is being handled. The loop runs over and over again, accounting for any changes in the state of the game. This is similar to how screens on devices work‚Äîthey refresh so many times a second, so fast that it's barely perceptible to the human eye.</p>
<p>Within the game loop, we'll keep track of everything that's happening, update state, and render text and images. It's important to begin to think about things in a loop, as it influences timing and code structure.</p>
<p>[TODO: drawing of the game loop and why it matters]</p>
<p>The game loop will begin to feel more natural over time, but for now, remember this: <strong>DRGTK runs the <code>tick</code> method 60 times every second</strong>.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next</a></h2>
<p>Let's get the player dragon moving around on the screen when we press certain keys. Player input is foundational to making games and a great next step.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="player-movement"><a class="header" href="#player-movement">Player Movement</a></h1>
<p>In the last chapter, we got a dragon sprite showing up on the screen and some text. Let's build upon that by making it so we can control the dragon with our keyboard and a gamepad. Because guess what? That dragon is now the main character of this game we're building. üêâ Buckle up, it's dragon riding time.</p>
<p>Simplify <code>mygame/app/main.rb</code> to be just this for now:</p>
<pre><code class="language-ruby">def tick args
  args.outputs.sprites &lt;&lt; [120, 280, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>That displays our player dragon and nothing else. Excellent. Let's get this dragon moving!</p>
<p>In order to handle moving the player, we need to keep track of the position across the game loops. This lets us know where the player was last <code>tick</code>, check if they should move, and then update the position accordingly.</p>
<p>Update your <code>mygame/app/main.rb</code> to be this:</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>There are a couple of new things here:</p>
<ul>
<li><code>args.state</code></li>
<li><code>||=</code></li>
</ul>
<p>Let's start with <code>args.state</code>. It's basically a blob that can be anything you want it to be, a bit like Kirby. Feed it <code>player_x</code> and it keeps track of it. Whatever you feed the <code>args.state</code>, it'll be accessible in future ticks. Keeping track of game state across ticks is important! It's part of the game loop. If we don't know where the player last was, how can we calculate where they should move to? We need to keep track of it in someplace. <code>args.state</code> is a fine place to start.</p>
<p>You can define anything on <code>args.state</code>, so it's up to you to use useful names. You could make <code>args.state.bleh</code> and set it to your favorite color, <code>args.state.bleh = &quot;blue&quot;</code> or your age, <code>args.state.age = 30</code>. Much like Kirby, <code>args.state</code> doesn't care what you feed it. It's just hungry for your data.</p>
<p>In this case, we're feeding it <code>||= 120</code>. What the heck is <code>||=</code>? Well... Maybe we need to start with <code>=</code>. You might read that as &quot;equals&quot; but it's actually the assignment operator. It means: set the thing on the left to the value on the right. It's a core programming concept. It's useful for assigning data to properties that we want to keep track of.</p>
<pre><code class="language-ruby">name = &quot;Francis&quot;
</code></pre>
<p>That code assigns the string Francis to the variable name. Then we can use <code>name</code> to refer to that value. It may not seem useful quite yet, but it will soon enough.</p>
<p>You could then use that variable like this:</p>
<pre><code class="language-ruby">puts name
</code></pre>
<p>That calls a the <code>puts</code> method and passes our argument <code>name</code> to it. It prints whatever the value is out to the console. If you put that in your game code and press <kbd>~</kbd> to open the console, you'll see it print <code>&quot;Francis&quot;</code> a bunch.</p>
<p><code>||=</code> in English is &quot;or equals&quot;. That code above, <code>args.state.player_x ||= 120</code> would be read as: assign the property <code>player_x</code> on <code>args.state</code> the numeric value of 120 unless it's alreay assigned a value.</p>
<p>Remember how tick is running once every 60 seconds? We don't want to always set <code>args.state.player_x</code> to <code>120</code>. We just want to set it to that initially and then we'll update that value when we press keys on our keyboard or buttons on our gamepad. We haven't done that yet, but that's what's next.</p>
<p>Wow! That was a lot of explaination for two measly lines of code. But I'm telling ya', they're two really important lines of code when it comes to game programming.</p>
<p>Then, finally, we change the <code>x</code> and <code>y</code> value for the dragon sprite to be the value stored in <code>args.state</code> so that we can actually make use of that value instead of our hard-coded position before.</p>
<h2 id="checking-for-input"><a class="header" href="#checking-for-input">Checking for Input</a></h2>
<p>In <code>tick</code> we'll check to see if a given input is pressed. If it is, we'll change the sprite's x and y position accordingly.</p>
<p>Our ole buddy <code>args</code> has a little something known as <code>args.inputs</code>. This lets us check... inputs! Isn't programming nice? Most of the time the words used in programming make sense. But some of the time, they really don't, and it's a gosh dang nightmare. But let's commit right here, right now to trying to name things in a way that's useful. Okay, you're committed. When you name a method <code>def thingy</code>, you'll remember this. And your ears will ring a little bit and your eyes will get just a little dry and you'll remember that you broke this commitment.</p>
<p>Let's make use of <code>args.inputs</code>:</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280

  if args.inputs.left
    args.state.player_x -= 10
  elsif args.inputs.right
    args.state.player_x += 10
  end

  if args.inputs.up
    args.state.player_y += 10
  elsif args.inputs.down
    args.state.player_y -= 10
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>You can now control the dragon with WASD, the arrow keys, or your controller. Pretty neat! It's almost fun. All it took was 10 lines of code. Let's break them down.</p>
<pre><code class="language-ruby">if args.inputs.left
  args.state.player_x -= 10
elsif args.inputs.right
  args.state.player_x += 10
end
</code></pre>
<p>This section checks for horizontal movement. If the left input is pressed, reduce the player's x position by 10 pixels. <code>-=</code> means, subtract the value on the right from the value on the left. It's the same as <code>args.state.player_x = args.state.player_x - 10</code>, but it's much more concise. We increase <code>player_x</code> to move right, decrease it to move left.</p>
<p><code>if</code> and <code>elsif</code> are conditional checks. The code only runs if the value is true (more specifically, truthy, but let's not worry about that yet).</p>
<pre><code class="language-ruby">if args.inputs.up
  args.state.player_y += 10
elsif args.inputs.down
  args.state.player_y -= 10
end
</code></pre>
<p>Then we check for vertical movement. We add to <code>player_y</code> to move up, decrease it to move down.</p>
<p>What if we wanted our dragon to move faster though? We could change those four instances of <code>10</code> to be <code>12</code> and see how that feels, sure. But that's annoying to update it all over. Let's make use of a variable! We'll call it <code>speed</code>:</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  speed = 10

  if args.inputs.left
    args.state.player_x -= speed
  elsif args.inputs.right
    args.state.player_x += speed
  end

  if args.inputs.up
    args.state.player_y += speed
  elsif args.inputs.down
    args.state.player_y -= speed
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>Whoa! We just refactored that code. It's easier to change (ETC) now, which is a sign we're improving things.</p>
<h2 id="boundaries"><a class="header" href="#boundaries">Boundaries</a></h2>
<p>You can move your dragon completely off the screen, lost in the great unknown! This isn't ideal. Let's make it so our little buddy can't leave the bounds of the screen.</p>
<p>[TODO: drawing about boundaries]</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  speed = 12
  player_w = 100
  player_h = 80

  if args.inputs.left
    args.state.player_x -= speed
  elsif args.inputs.right
    args.state.player_x += speed
  end

  if args.inputs.up
    args.state.player_y += speed
  elsif args.inputs.down
    args.state.player_y -= speed
  end

  if args.state.player_x +  player_w &gt; args.grid.w
    args.state.player_x = args.grid.w - player_w
  end

  if args.state.player_x &lt; 0
    args.state.player_x = 0
  end

  if args.state.player_y + player_h &gt; args.grid.h
    args.state.player_y = args.grid.h - player_h
  end

  if args.state.player_y &lt; 0
    args.state.player_y = 0
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, player_w, player_h, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>Our dragon won't leave the screen. Woot woot! We've got some serious code here! Look at that logic. Here's what changed:</p>
<p>We moved the width and height of the player into variables so that they're easier to reference and reuse. Boom. We need those to do some math on the boundaries too. There's a general programming idea out there known as Don't Repeat Yourself (DRY). As soon as you have a piece of code, especially a number, that represents a value and is used multiple times, put it in a variable. This makes its intent clear as to what it represents and makes it easier to change. Win-win.</p>
<p>Here's the good stuff. We check the boundary for the x axis:</p>
<pre><code class="language-ruby">  if args.state.player_x +  player_w &gt; args.grid.w
    args.state.player_x = args.grid.w - player_w
  end

  if args.state.player_x &lt; 0
    args.state.player_x = 0
  end
</code></pre>
<p>We check the right side of the screen: if the current player's x position plus their width is greater than <code>args.grid.w</code>, then we set the x position to the width of the screen (<code>args.grid.w</code>) minus the width of the sprite. For example, if we move the sprite so it has the x position of 1284, 4 pixels past the right edge of the screen, we override that change and set it to 1280 minus the player's width.</p>
<p>It's so important that this happens after checking for input. You don't want to change <code>args.state.player_x</code> after this check, otherwise the boundary won't be enforced. Order matters with the code we write within <code>tick</code>.</p>
<p><code>args.grid.w</code> is the width of the screen. It's always 1280, but we don't want to have that magic number in our code. So we use <code>args.grid.w</code>.</p>
<p>Next we check the left side of the screen: if the player's x is less than 0, then we set it to zero. That's a bit similar to the right side, just simpler.</p>
<p>Then we do the same thing for the top and bottom of the screen by checking the y position.</p>
<h2 id="extra-credit"><a class="header" href="#extra-credit">Extra Credit</a></h2>
<ul>
<li>When you move the dragon horizontally and vertically at the same time, the dragon moves twice as fast. How could you make it so the dragon moves at a uniform speed still when that happens?</li>
</ul>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next</a></h2>
<p>In the next chapter we'll make our dragon spit fireballs when we press a key or button. Watch out!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spit-fire"><a class="header" href="#spit-fire">Spit Fire</a></h1>
<p>Our next mission is to make our dragon spit fire because that's just what they do. We'll piece this whole thing into a game with win and lose states, a narrative, and intentional design soon enough. But let's keep focusing on simple mechanics and the code for right now.</p>
<h2 id="fire-on-input"><a class="header" href="#fire-on-input">Fire on Input</a></h2>
<p>In the last chapter, we used <code>args.inputs</code> to check for player input from the four main directions. If those inputs were being pressed, then we moved the dragon. Now let's check to see if the <kbd>Z</kbd> key is pressed to know when to have our dragon spit a fireball.</p>
<p>To check if a key was pressed, we can use <code>args.inputs.keyboard.key_down</code> and then whatever key we want to check. So in our case, we'll check <code>args.inputs.keyboard.key_down.z</code>. In our <code>#tick</code> method, right above where we render the dragon sprite, let's check for that input:</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z
    puts &quot;Z key pressed&quot;
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, player_w, player_h, 'sprites/misc/dragon-0.png']
</code></pre>
<p>Using <code>puts</code> is a really helpful way to check that our game works as we expect it to. In this case, every tick where the Z key is pressed down, it prints the string &quot;Z key pressed&quot; to the console (open it iwth <kbd>~</kbd>, remember?). Run your game and press the Z key a bunch and then open your console.</p>
<img alt="screenshot of DragonRuby console showing Z key pressed 6 times" src="./img/c03-console-puts.jpg" style="max-width: 420px; width: 100%;">
<h2 id="expanded-control-support"><a class="header" href="#expanded-control-support">Expanded Control Support</a></h2>
<p>When making a game, it's important to support a variety of input configurations to make the game as accessible as possible. Sure, the keyboard arrow keys and the Z key are sensible defaults. But what if our player wants to use a gamepad controller? Or what if they would prefer to use WASD for movement? From the start of coding player input, let's support as many different inputs as reasonably possible.</p>
<p>In our case, we'll support three configurations:</p>
<ul>
<li>Arrow keys and Z</li>
<li>WASD and J</li>
<li>Gamepad</li>
</ul>
<p>DragonRuby GTK is a big help in this department. Our code earily that checks <code>args.inputs.up</code> (down/left/right) already checks for the arrow keys, WASD, and gamepad input. Slick! We don't have to change anything there. But let's go ahead and update our logic check for firing the fireball to check all of the possible inputs.</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    puts &quot;Spit fireball!&quot;
  end
</code></pre>
<p>We learned about <code>||=</code> earlier, and that's a combination of two separate operators in Ruby. <code>||</code> represents &quot;or&quot; and <code>=</code> says to assign a value. If the value on the left doesn't have a value, assign it the value on the right. We can make use of the &quot;or&quot; (<code>||</code>) operator independently of the assignment operator (<code>=</code>) to control the logic within our game.</p>
<p>The code above says: if the z key is down OR the j key is down OR the A button on the gamepad is pressed, then output the string to the console.</p>
<p>You can combine <code>||</code> on one line (<code>if monday || tuesday || wednesday</code>), but it can be helpful to break long lines to make our code easier to read.</p>
<p>Outputting info to the console isn't that helpful for the player, but can you begin to imagine how we'll use that check to instead display a fireball.</p>
<h2 id="displaying-fireballs"><a class="header" href="#displaying-fireballs">Displaying Fireballs</a></h2>
<p>We want to display a fireball on the screen when the action key is pressed. We've got most of the code, all we need to do is change <code>puts</code> to instead display the fireball.</p>
<p>At the top of <code>#tick</code> (<code>#whatever</code> is Ruby shorthand for &quot;the whatever method&quot;), assign an empty array to <code>args.state.fireballs</code> if nothing has been assigned yet. This will let us keep track of fireballs across the game loop to do all sorts of things with them (display them, move them, collide them with other objects):</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  args.state.fireballs ||= []
</code></pre>
<p>Then where we check for the action input, push a fireball into the <code>arg.state.fireballs</code> array based on the current player's x and y position:</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    args.state.fireballs &lt;&lt; [args.state.player_x, args.state.player_y, 'fireball']
  end

  args.outputs.labels &lt;&lt; args.state.fireballs

</code></pre>
<p>Then all we have to do is render our fireballs by pushing them into the <code>args.outputs.labels</code> collection. DragonRuby is smart enough to know that if we push an array into any <code>args.outputs</code> collection it'll flatten it and display them correctly. Thanks, DragonRuby!</p>
<p>Play your game and see what happens! Fireballs everywhere. Wait! You're not impressed by those fireballs? I'd be pretty frightened if the word fireball was flying at me.</p>
<p><img src="./img/c03-fireball-display.jpg" alt="screenshot of the game showing the word 'fireball' throughout with the dragon flying around" /></p>
<p>Wait, where are you going? Why are you muttering &quot;I didn't sign up to read no stinkin' book where you output the word fireball on the screen, I'm here for the real flame, the good stuff...&quot;</p>
<h2 id="moving-fireballs"><a class="header" href="#moving-fireballs">Moving Fireballs</a></h2>
<p>Guess what? We're sticking with ole &quot;fireball&quot; for now! It's silly and fun and I haven't found a good fireball sprite to use. We'll get there, we'll get there. But let's first make the fireballs move across the screen.</p>
<p>When we moved our player dragon, we took the x and y position and added or substracted values in each <code>#tick</code> based upon if any directional input was pressed. Our fireballs will move regardless of any button pressed once they're extruded from our ole dragon's mouth. Because our game is simple and the dragon only faces to the right, all of the fireballs will move to the right. How do we go about that on our X-Y axis? We just increase the <code>x</code> position of the fireball each tick. Let's do that and see what happens:</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    args.state.fireballs &lt;&lt; [args.state.player_x, args.state.player_y, 'fireball']
  end

  args.state.fireballs.each do |fireball|
    fireball[0] += speed + 2
  end

  args.outputs.labels &lt;&lt; args.state.fireballs
</code></pre>
<p>Right between where we add a new fireball to <code>args.state.fireballs</code> and we display them using <code>args.outputs.labels</code>, our new code does this:</p>
<ol>
<li>Loop through the array of <code>args.state.fireballs</code></li>
<li>For each fireball, update the array value at the <code>0</code> index, which is the x position of the fireball, to be the dragon's speed plus 2 (because we want the fireball to move faster than the dragon).</li>
</ol>
<p>Move your dragon around, spit some fire, and bask in the glory of a word moving so smoothly across the screen that it almost looks like a... fireball!</p>
<p>Try changing around <code>speed + 2</code> to make the fireballs move faster or slower and see how that feels. Adjusting speed values can really change the vibe of your game and is important in tuning it to feel just right.</p>
<p>There's a lot of important concepts in those three newly added lines of code. In Ruby, when there's an array of data, we can loop through <strong>each</strong> item and modify their properties. Games are composed of huge collections of things: enemies, fireballs, menu options, player inventory. Arrays (and just collections in general) aren't anything to be afraid of, and soon enough, you'll be thinking about your games in them.</p>
<p>Looping through an array of data in each <code>#tick</code> and then doing <em>something</em> is the stuff games are made of! Here are some ways this can be applied in all sorts of games: enemy behavior, checking for collision, animating. As our game (and any game you make) gets more complex, looping through collections of data becomes more and more common.</p>
<p>[TODO: illustration of game loop and then a little loop inside where we loop through collections]</p>
<h2 id="switching-to-hashes"><a class="header" href="#switching-to-hashes">Switching to Hashes</a></h2>
<p>So far throughout the book we've been using arrays to represent the entities in our game, whether it be the player's dragon sprite or our fireball text that gets displayed. Remember <code>[args.state.player_x, args.state.player_y, 'fireball']</code>? Arrays are wonderful and important, but they aren't so great for representing structured data because it's difficult to remember what each piece of data in the array's positions represents. Remembering that <code>fireball[2]</code> is the text value and not the y value is tricky. Luckily, DragonRuby has a more verbose and clear data structure we can use for managing our data. It's called a hash! Much like arrays, hashes are extremely useful.</p>
<p>Let's look at what the text example above would be like as a hash:</p>
<pre><code class="language-ruby">{
  x: args.state.player_x,
  y: args.state.player_y,
  text: &quot;fireball&quot;,
}
</code></pre>
<p>Hashes are expressed through curly braces <code>{}</code> and contain <code>key: value</code> separated by commas. The values of a hash can be anything, from numbers to strings to whatever your heart desires. Let's say we wanted to build our own hash to represent a dragon and put it in the <code>dragon</code> variable:</p>
<pre><code class="language-ruby">dragon = {
  name: &quot;Francis&quot;,
  size: &quot;medium&quot;,
  age: 541,
}
</code></pre>
<p>Values of a hash are then accessed by their keys, so you <code>dragon.name</code> returns the string <code>&quot;Francis&quot;</code>, <code>dragon.size</code> returns the string <code>&quot;medium&quot;</code>, and <code>dragon.age</code> returns the number <code>541</code>. This is much more clear than having to remember the position of these values within an array.</p>
<p>In general, differentiate between arrays and hashes like this: <strong>hashes are used represent one piece of data with multiple properties</strong> and <strong>arrays are used to collect data (often times hashes) to keep track of and manipulate them</strong>.</p>
<p>Below is our entire game translated to use hashes instead of arrays for our rendering:</p>
<pre><code class="language-ruby">def tick args
  args.state.player ||= {
    x: 120,
    y: 280,
    w: 100,
    h: 80,
    speed: 12,
    path: 'sprites/misc/dragon-0.png',
  }
  args.state.fireballs ||= []

  if args.inputs.left
    args.state.player.x -= args.state.player.speed
  elsif args.inputs.right
    args.state.player.x += args.state.player.speed
  end

  if args.inputs.up
    args.state.player.y += args.state.player.speed
  elsif args.inputs.down
    args.state.player.y -= args.state.player.speed
  end

  if args.state.player.x +  args.state.player.w &gt; args.grid.w
    args.state.player.x = args.grid.w - args.state.player.w
  end

  if args.state.player.x &lt; 0
    args.state.player.x = 0
  end

  if args.state.player.y + args.state.player.h &gt; args.grid.h
    args.state.player.y = args.grid.h - args.state.player.h
  end

  if args.state.player.y &lt; 0
    args.state.player.y = 0
  end

  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    args.state.fireballs &lt;&lt; {
      x: args.state.player.x,
      y: args.state.player.y,
      text: 'fireball',
    }
  end

  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2
  end

  args.outputs.labels &lt;&lt; args.state.fireballs
  args.outputs.sprites &lt;&lt; args.state.player
end
</code></pre>
<p>It may not seem like much has changed, but there are two key changes that make this worthwhile:</p>
<ol>
<li><code>fireball.x += args.state.player.speed + 2</code> ‚Äî it is much clearer when we move the fireball that we're adding to its <code>x</code> position AND using the player's speed</li>
<li><code>args.outputs.sprites &lt;&lt; args.state.player</code> ‚Äî because we're keeping track of our player in <code>args.state.player</code> and it has the data DragonRuby needs to render it, we can just push it into <code>args.outputs.sprites</code> and not construct the array that we used to use</li>
</ol>
<h2 id="displaying-a-sprite"><a class="header" href="#displaying-a-sprite">Displaying a Sprite</a></h2>
<p>With that refactor done, let's display a sprite for our fireball and call it a chapter.</p>
<p>Download the fireball sprite below and put it in <code>mygame/sprites/fireball.png</code>:</p>
<p><img src="./code/chapter_03/06_sprite/sprites/fireball.png" alt="fireball sprite" /></p>
<p>We'll change the hash we push into <code>args.state.fireballs</code> to be a sprite and adjust how we render that collection. Nothing too major. Here's the changes near the bottom of <code>#tick</code> that you'll need to make:</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    args.state.fireballs &lt;&lt; {
      x: args.state.player.x + args.state.player.w - 12,
      y: args.state.player.y + 10,
      w: 32,
      h: 32,
      path: 'sprites/fireball.png',
    }
  end

  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2
  end

  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs]
</code></pre>
<p>We adjust the starting place of the fireball sprite to look like it comes out of the dragon's mouth. The sprite is 32 pixels wide by 32 pixes tall, so we set that.</p>
<p>Now that the fireball is a sprite and not a text label, we can push both the player and the array of fireballs into <code>args.outputs.sprites</code> in one go. This is more efficient for DragonRuby than doing it separately.</p>
<p><img src="./img/c03-fireball-sprite.jpg" alt="dragon sprite shooting 4 fireballs flying across the screen" /></p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's Next</a></h2>
<p>We're so close to having a game, so close! We just need something to spit fireballs at, right? We'll display some floating targets that get destroyed on when a fireball hits them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="target-practice"><a class="header" href="#target-practice">Target Practice</a></h1>
<p>For a dragon to gain accuracy in the fine art of breathing fire, they need to practice, right? Let's build out a feature where targets randomly spawn for our fireballs to collide with. We'll keep track of how many targets we've hit and use that as the main scoring component of our game.</p>
<h2 id="displaying-targets"><a class="header" href="#displaying-targets">Displaying Targets</a></h2>
<p>First, let's download the target sprite and put it in <code>mygame/sprites/target.png</code>:</p>
<p><img src="./code/chapter_04/01_display_targets/sprites/target.png" alt="target sprite" /></p>
<p>We'll keep track of the targets in an array, just like fireballs, so that we can more easily manage them throughout our game loop. Instead of initializing our targets as an empty array, let's start by displaying three of them:</p>
<pre><code class="language-ruby">  args.state.fireballs ||= []
  args.state.targets ||= [
    {
      x: 800,
      y: 120,
      w: 64,
      h: 64,
      path: 'sprites/target.png',
    },
    {
      x: 920,
      y: 600,
      w: 64,
      h: 64,
      path: 'sprites/target.png',
    },
    {
      x: 1020,
      y: 320,
      w: 64,
      h: 64,
      path: 'sprites/target.png',
    },
  ]
</code></pre>
<p>We need to render our target sprites too, so include those in the array we push into <code>args.outputs.sprites</code>:</p>
<pre><code class="language-ruby">  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs, args.state.targets]
</code></pre>
<p>Similar to how we represent the player and fireball sprites, the targets have an and x and y coordinate for position, a width and height, and an image file to represent the sprite. We create three items in our <code>args.state.targets</code> array, which then displays three different targets.</p>
<p><img src="./img/c04-display-targets.jpg" alt="dragon sprite with three targets rendered to the right" /></p>
<p>Try changing the <code>x</code> and <code>y</code> positions of our three targets. Weird. They don't change their position...</p>
<p>If you quit your game and relaunch <code>dragonruby</code>, they will though. Why is that?</p>
<p>Well, when DragonRuby loads our game code, if any value is set in <code>args.state</code> via <code>||=</code>, it won't reassign the new value because that value is already set. <code>args.state.targets</code> already has three targets in it, so when our code is reloaded, it doesn't know to discard our old targets.</p>
<p>Let's instruct DragonRuby to reset our state when the game runs by adding the special <code>$gtk.reset</code> after the <code>end</code> of <code>#tick</code>:</p>
<pre><code class="language-ruby">  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs, args.state.targets]
end

$gtk.reset
</code></pre>
<p>Now if we change the coordinates of our target, the game reloads our code and they change their position. This is a really awesome aspect of DragonRuby. We can easily adjust and modify the running game without having the rebuild it.</p>
<h2 id="our-first-method"><a class="header" href="#our-first-method">Our First Method</a></h2>
<p>There's something that's a bit of a bummer about our target array code. We duplicate a lot of values by having to specify the width, height, and image path. It'd be a bit annoying to have to change it in all those places even though we want them to be the same. Let's introduce our first method. While <code>#tick</code> is called automatically by DragonRuby, we can define our own methods that we call in our game to help organize our code. Methods are great for encapsulating a specific action. In our case, let's define a method that creates a target at a given x and y position.</p>
<pre><code class="language-ruby">def spawn_target x, y
  {
    x: x,
    y: y,
    w: 64,
    h: 64,
    path: 'sprites/target.png',
  }
end

def tick args
  args.state.player ||= {
    x: 120,
    y: 280,
    w: 100,
    h: 80,
    speed: 12,
    path: 'sprites/misc/dragon-0.png',
  }
  args.state.fireballs ||= []
  args.state.targets ||= [
    spawn_target(800, 120),
    spawn_target(920, 600),
    spawn_target(1020, 320),
  ]
</code></pre>
<p>Within <code>main.rb</code> we can define methods that are able to be called in <code>#tick</code>. Our new <code>spawn_target</code> method takes two parameters, the x and the y position, and then uses those parameters to return a hash representing the new target. In Ruby, method parameters are separated by commas. We pass parameters into methods that we want to have access to within that code. Because the width, height, and image don't change for a given target, those values stay the same and aren't passed in as parameters.</p>
<p>Then when we lazily assign <code>args.state.targets ||=</code>, we call the method three times, passing in the coordinates we want the target to spawn at.</p>
<p><code>#spawn_target</code> is a simple method, but we'll begin to see how we can expand upon the methods we write to make our code easy to understand while it gets more complex.</p>
<h2 id="collision-detection"><a class="header" href="#collision-detection">Collision Detection</a></h2>
<p>The fireballs our dragon spits just fly behind our targets and off the screen into infinity. Let's make it so that if a fireball hits a target, <em>something</em> happens. Eventually we'll want to play a sound, remove the target, and even play an animation. But humble beginnings, humble beginnings.</p>
<p>Collision detection is when one object overlaps with another object in our game. Because we're manufacturing the space the game exists in, there's no physics like we have in real life. We need to simulate that by checking to see if two objects are attempting to exist in the same point and react accordingly.</p>
<p>Our fireball sprite is a 32x32 square, so we want to check in every single game loop whether or not the points of the fireball's square overlapping with any of the points of the targets. If they are overlapping, then we do that <em>something</em>.</p>
<p>TODO: graphic of overlapping rects/squares explained</p>
<p>We could employ trigonometry to determine if a given point in one shape overlaps with another, but DragonRuby gives us a helpful method to handle this for us: <code>args.geometry.intersect_rect? rect_1, rect_2</code></p>
<p>It may seem odd that we're checking the intersection of two rectangles when our target is a circle and our fireball is almost a circle. Most 2D games use rectangles for their collision detection for the simplicity of it. Our images are already rectangles, and it's close enough for our purposes.</p>
<p>Here's the written out logic behind the collision detection we'll implement:</p>
<ul>
<li>In each <code>#tick</code>, keep our code for looping through and moving each fireball</li>
<li>After we move a fireball, loop through each target and check if the fireball is overlapping any of them</li>
<li>If they do overlap, output a message to the console</li>
</ul>
<pre><code class="language-ruby">  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        puts &quot;fireball hit target!&quot;
      end
    end
  end
</code></pre>
<p>Play the game and hit the some targets. Nothing visually happens (yet), but if you check the console (<kbd>~</kbd>), you'll see that <code>&quot;fireball hit target&quot;</code> was output multiple times.</p>
<p>With a loop and a method we've implemented collision detection. That wasn't too bad, was it?</p>
<h2 id="remove-targets-on-collision"><a class="header" href="#remove-targets-on-collision">Remove Targets On Collision</a></h2>
<p>But... It's not very helpful to output a message to the console when a target is hit. Let's instead remove the target so that it is no longer displayed. We'll need to delete the hit target from the array of targets so that it's no longer checked against.</p>
<p>Ruby makes that pretty easy. All you do is call the <code>#delete</code> method on an array and pass in the item you want to delete. If you have an array of numbers and call delete, it removes the item from the array:</p>
<pre><code class="language-ruby">nums = [3, 4, 5]
nums.delete(3)
nums # =&gt; [4, 5]
</code></pre>
<p>It works just like you think it would. So in our collision detection code where we call <code>puts</code>, we'll instead just delete the target <em>and</em> the fireball so they both get removed from their respective collections.</p>
<pre><code class="language-ruby">  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
      end
    end
  end
</code></pre>
<p>Since the target and fireball that collided are no longer being tracked in <code>args.state</code>, they don't get rendered on the screen and are, for all intents and purposes, gone!</p>
<p>This almost feels like a game. That's a great feeling. We're getting close to <em>fun</em>.</p>
<h2 id="spawn-new-targets"><a class="header" href="#spawn-new-targets">Spawn New Targets</a></h2>
<p>Shooting three targets and having them disappear doesn't make for much fun though. After the three targets are hit, it's just your dragon floating in the sky with not much else to do. We're back to chapter 3! Ugh, chapter 3 was so boring! I can't believe we ever even made anything that boring before. (But remember how cool it was when we got the fireballs working? That was cool! It's funny how games evolve and what it used to be seems so basic compared to where we're at now.)</p>
<p>Remember back in the day, way back when, like a few sections ago, when we introduced <code>#spawn_target</code>? It was helpful then, but now it's going to be even more helpful. We'll call it every time we destroy a target so that a new one spawns. We'll be able to play target practice forever!</p>
<p>But calling <code>spawn_target</code> with the same x and y over and over isn't a lot of fun. So let's make a few related changes where we'll do the following:</p>
<ol>
<li>Determine a random x and y position on the screen to spawn the target</li>
<li>Remove the x and y for our initial three targets so they get a random position</li>
<li>Spawn a new target in a random position when we hit one</li>
</ol>
<h3 id="spawn-at-a-random-location"><a class="header" href="#spawn-at-a-random-location">Spawn at a random location</a></h3>
<pre><code class="language-ruby">def spawn_target(args)
  size = 64
  {
    x: rand(args.grid.w * 0.4) + args.grid.w * 0.6,
    y: rand(args.grid.h - size * 2) + size,
    w: size,
    h: size,
    path: 'sprites/target.png',
  }
end
</code></pre>
<p><code>#spawn_target</code> looks a little different now. We no longer pass in the coordinates as arguments because we'll randomly generate the position. We instead pass in <code>args</code> from DragonRuby's <code>#tick</code> so that we can get the width and height of the screen to use to determine boundaries.</p>
<p>We create a <code>size</code> variable to store the width and height of the sprite to use in our formulas for spawning the target. We don't want to have to type 64 over and over because it loses its meaning and gets difficult to change.</p>
<p>Then we apply some math. Don't let math scare you away from programming! We'll keep it simple and the toolbox you need is relatively small. Plus, the math will help make our game even better. Games make math fun.</p>
<p><code>rand</code> is a method that we get from DragonRuby that's available everywhere. <code>rand</code> without any paramter generates a random number between 0 and 1. That's not really useful for us right now, so we can instead pass in a parameter that sets the upper boundary of the random number. <code>rand(100)</code> generates a random number between 0 up to 100 (not including 100).</p>
<p>So for the x position of the target, we generate a number random number that's up to two-fifths the size of width of the game and then we add three-fifths of the width to that number so that the targets spawn on the far right side of the screen. We don't want to spawn targets too close to the player, otherwise it'd be too easy.</p>
<p>For the y position, we generate a random y position based on the height of the game, but we subtract twice the size of the target sprite and then add one of its sizes back to the random number to give the spawn area a gutter. This prevents the target from spawning partially off the screen, which would make it impossible to hit.</p>
<h3 id="change-initial-three-targets"><a class="header" href="#change-initial-three-targets">Change initial three targets</a></h3>
<pre><code class="language-ruby">  args.state.targets ||= [
    spawn_target(args), spawn_target(args), spawn_target(args)
  ]
</code></pre>
<p>Instead of passing in the x and y position, we just call <code>#spawn_target</code> with DragonRuby's <code>args</code> so that we have access to the grid in our method. This gives us three randomly located targets.</p>
<h3 id="spawn-a-new-target-when-one-is-hit"><a class="header" href="#spawn-a-new-target-when-one-is-hit">Spawn a new target when one is hit</a></h3>
<pre><code class="language-ruby">  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
        args.state.targets &lt;&lt; spawn_target(args)
      end
    end
  end
</code></pre>
<p>We loop through the fireballs and move each one, just as before. And then we check to see if it intersects with any of the targets. If they do intersect, we delete both the fireball and the target.</p>
<p>The one new line is where we push a new target into <code>args.state.targets</code> from <code>#spawn_target</code>. That'll make a new target appear in a random location whenever we hit another.</p>
<p>Play the game a bit and see how feels. Is there anything that can be adjusted or improved? What if you adjust the formula for <code>#spawn_target</code>? How does that feel with targets spawning close or further away?</p>
<h2 id="score-tracking"><a class="header" href="#score-tracking">Score Tracking</a></h2>
<p>Let's keep track of how many targets we've destroyed before we call it a chapter.</p>
<p>The approach for this is pretty simple. We'll store a number in <code>args.state.score</code> and increase it each time we hit a target. Then we'll display that number on the screen as a label.</p>
<p>Near the top of <code>#tick</code>, lazily initialize <code>args.state.score</code> to <code>0</code>.</p>
<pre><code class="language-ruby">  args.state.fireballs ||= []
  args.state.targets ||= [
    spawn_target(args), spawn_target(args), spawn_target(args)
  ]
  args.state.score ||= 0

  if args.inputs.left
</code></pre>
<p>In our collision detection loop, when we delete the target and fireball, add <code>1</code> to our score:</p>
<pre><code class="language-ruby">        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
        args.state.score += 1
        args.state.targets &lt;&lt; spawn_target(args)
</code></pre>
<p>Finally, display our score as a label in the upper-left area of the screen:</p>
<pre><code class="language-ruby">  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs, args.state.targets]
  args.outputs.labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 40,
    text: &quot;Score: #{args.state.score}&quot;,
    size_enum: 4
  }
</code></pre>
<p>This approach to displaying a label is different than previous chapters. Instead of using an array to represent the properties of the label, we're now using a hash like we do for sprites (for similar reasons: it's easier to remember and more clear). Setting <code>x</code>, <code>y</code>, and <code>text</code> should be familiar by this point. But <code>size_enum</code> is new. It's a way to specify how large the text is. It takes whatever value we set and adds that much to the default text size. Increase it from <code>4</code> to <code>40</code> or <code>-3</code> and see what you lik ebest.</p>
<p><img src="./img/c04-score.jpg" alt="dragon spitting fireballs at three targets on the right side of the screen with the text 'Score: 34' displayed" /></p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>What a chapter! We displayed targets, handled collision detection, spawned our targets randomly, and added score tracking. We've come a long way in this chapter. And added a lot of core concepts that are found in most games. Review the code to make sure you understand it.</p>
<h2 id="extra-credit-1"><a class="header" href="#extra-credit-1">Extra Credit</a></h2>
<ul>
<li>There's a chance that our randomly generated targets can spawn on top of each other. How can you make it so that doesn't happen?</li>
<li>How could you change the collision detection to check if two circles overlap instead of rectangles?</li>
<li>We added gutters for the y position of our targets in <code>#spawn_target</code> for the top and bottom of the game screen, but how would you add a gutter for the x position so they don't spawn partially off the screen on the right side?</li>
</ul>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What's Next</a></h2>
<p>We'll take a brief side quest where we ask some big existential questions and clean up our fireballs that have flown off the screen before we turn this project we've been working on into a game that we can play and finish.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fireball-clean-up"><a class="header" href="#fireball-clean-up">Fireball Clean Up</a></h1>
<p>Time for a little side quest from the progress we've been making to clean up a small mess we've been making and learn a bit about performance optimizations.</p>
<p>As you've been shooting fireballs, have you wondered at all about what happens to all of those fireballs that fly off the right side of the screen?</p>
<p>Do you think they just... keep flying forever? Or do you think they just disappear from our game and our lives?</p>
<p>What if I told you that they don't disappear!</p>
<p>Whoa.</p>
<p>We could shoot thousands of fireballs that don't hit a target and our game is keeping track of them and updating their position over time. Let's demonstrate that.</p>
<h2 id="tracking-offscreen-fireballs"><a class="header" href="#tracking-offscreen-fireballs">Tracking Offscreen Fireballs</a></h2>
<p>DragonRuby gives us <code>args.outputs.debug</code>, which allows us to display shapes, labels, sprites, and more only when we're making our game. If we built it for release, the debug outputs wouldn't be displayed. Pretty nifty and really helpful for visually displaying information in each frame of our game.</p>
<p>Add these lines to the bottom of <code>#tick</code> after pushing our score text into <code>args.outputs.labels</code>:</p>
<pre><code class="language-ruby">  args.outputs.debug &lt;&lt; {
    x: 40,
    y: args.grid.h - 80,
    text: &quot;Fireballs: #{args.state.fireballs.length}&quot;,
  }.label!
  args.outputs.debug &lt;&lt; {
    x: 40,
    y: args.grid.h - 100,
    text: &quot;1st fireball x pos: #{args.state.fireballs.first&amp;.x}&quot;,
  }.label!
</code></pre>
<p>It displays two pieces of text in our game (but remember, only in debug mode). The total number of fireballs our game is keeping track of and the x position of the first fireball. The ampersand in front of <code>args.state.fireballs.first&amp;.x</code> says: if there's a first fireball, try to get its x property, otherwise don't throw an error. If we haven't hit the fire button, there's no first fireball in our array to get the <code>x</code> value of.</p>
<p><img src="./img/c05-debug-text.jpg" alt="debug mode text showing the dragon sprite with a score of 3, 36 fireballs, and an x position of the first fireball at 22,356" /></p>
<p>Spit a bunch of fireballs out and let your game run. You'll see the dozens of fireballs just keep going on and on forever, their x position steadily increasing.</p>
<h2 id="optimizing-our-game"><a class="header" href="#optimizing-our-game">Optimizing Our Game</a></h2>
<p>It's not very efficient to keep track of and update the position of fireballs that have no chance of ever hitting a target when they've gone off the screen. There could be thousands of fireballs, and sure, maybe our game still runs smoothly while we're testing, but there's a high chance that as our game gets more complex, there the sheer amount of data the game needs to process 60 times every second could get overwhelming and slow things down.</p>
<p>When making games, you need to be cognizant of performance. There are usually some straightforward fixes that can make a big difference.</p>
<p>In the case of our game, let's remove fireballs from our <code>args.state.fireballs</code> array when they fly off the screen. This will reduce the amount of processing load our game needs to handle.</p>
<pre><code class="language-ruby">  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    if fireball.x &gt; args.grid.w
      args.state.fireballs.delete(fireball)
      next
    end

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
        args.state.score += 1
        args.state.targets &lt;&lt; spawn_target(args)
      end
    end
  end
</code></pre>
<p>When looping through <code>args.state.fireballs</code>, we check to see if the x position of the fireball in the loop is greater than the width of the screen. If it is, then we delete the fireball, just like we do below on collision with a target. Then we call <code>next</code>, which tells the loop we're in to move on to the next fireball in the array and not the rest of the code in this iteration of the loop. Since we've removed the fireball from the game, we don't want to check it for collision.</p>
<p>Play your game and see that now as the fireballs fly off the screen, the total number of fireballs decreases. They no longer exist forever, flying off across the sky for all eternity, eating up our CPU cycles.</p>
<p>Feel free to remove the <code>args.outputs.debug</code> lines if you don't want to see them since they've served their purpose and are less useful now.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>There will be many opportunities when working on your games to optimize your code so that it performs better. This was just a taste of what that process can be like. As you get better and better at making games, you'll improve at making them more performant.</p>
<p>Don't obsesses over performance too much yet though. Focus on making your game fun to play.</p>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What's Next</a></h2>
<p>Now that we've cleaned up a small mess we've been making, let's get back to taking our game to the finish line by adding a timer to our game to see how many targets we can hit in 30 seconds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-attack"><a class="header" href="#time-attack">Time Attack</a></h1>
<p>We've <em>almost</em> got a game. But we need some way for the game to end. A lot of game loops end with the player's character dying, where they respawn or start over again. Other game loops end when the player reaches the end of a level.</p>
<p>For our simple game, let's add a 30 second timer that counts down. The objective of our game will be to see how many targets can the player hit in that time window. Let's call our game <strong>Target Practice</strong>. Every dragon needs some practice before they head out into battle, right?</p>
<p>Adding a timer to our game introduces a few new concepts we'll build out in this chapter:</p>
<ol>
<li>Keeping track of time and displaying it</li>
<li>Stopping our game when the timer runs out</li>
<li>Displaying a Game Over screen with the score</li>
<li>Allowing the player to restart the game and play again</li>
</ol>
<h2 id="getting-it-working"><a class="header" href="#getting-it-working">Getting It Working</a></h2>
<p>We'll start by introducing <code>args.state.timer</code> that will be used to keep track of how much time remains.</p>
<pre><code class="language-ruby">  args.state.score ||= 0
  args.state.timer ||= 30 * 60

  args.state.timer -= 1
</code></pre>
<p>We lazily set it to <code>30 * 60</code>. We want the game to last thirty seconds and our <code>#tick</code> method runs sixty times every second, so we multiple them together to get the total number of ticks our timer will run for. We'll then subtract one from <code>args.state.timer</code> every <code>#tick</code> so that it decreases as we play our game.</p>
<p>Right below decreasing our <code>args.state.timer</code> by one, we check to see if the timer is less than zero. If it is, that means game over.</p>
<pre><code class="language-ruby">  args.state.timer -= 1

  if args.state.timer &lt; 0
    labels = []
    labels &lt;&lt; {
      x: 40,
      y: args.grid.h - 40,
      text: &quot;Game Over!&quot;,
      size_enum: 10,
    }
    labels &lt;&lt; {
      x: 40,
      y: args.grid.h - 90,
      text: &quot;Score: #{args.state.score}&quot;,
      size_enum: 4,
    }
    labels &lt;&lt; {
      x: 40,
      y: args.grid.h - 132,
      text: &quot;Fire to restart&quot;,
      size_enum: 2,
    }
    args.outputs.labels &lt;&lt; labels

    if args.inputs.keyboard.key_down.z ||
        args.inputs.keyboard.key_down.j ||
        args.inputs.controller_one.key_down.a
      $gtk.reset
    end

    return
  end
</code></pre>
<p>If it is game over, then we let the player know, display their final score, and tell them how to play again (by pressing the fire button). We make an array of labels which we then push into <code>args.outputs.labels</code> to efficiently render them all.</p>
<p>If any of our fire keys are pressed, the game is reset with <code>$gtk.reset</code> and the player can play again.</p>
<p>The <code>return</code> line is <em>really</em> important. It says, return out of the <code>#tick</code> method so that none of the code below runs. We don't want to have the dragon be moveable or for targets to spawn when it's game over. So we eject early and only display the game over screen details.</p>
<p><img src="./img/c06-game-over.jpg" alt="game over screen showing a score of 11 with text saying 'Fire to restart'" /></p>
<p>Way at the bottom of <code>#tick</code>, let's display a label with the time remaining:</p>
<pre><code class="language-ruby">  labels = []
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 40,
    text: &quot;Score: #{args.state.score}&quot;,
    size_enum: 4,
  }
  labels &lt;&lt; {
    x: args.grid.w - 40,
    y: args.grid.h - 40,
    text: &quot;Time Left: #{(args.state.timer / 60).round}&quot;,
    size_enum: 2,
    alignment_enum: 2,
  }
  args.outputs.labels &lt;&lt; labels
</code></pre>
<p>We use the same pattern of creating a <code>labels</code> array, pushing in the player's score and the time remaining. In order to get the time remaining, we divide it by 60 and round. We do the opposite of what we did when we set the total time in ticks.</p>
<p>The <code>alignment_enum</code> let's us specify that we want the text to be right aligned instead of the default left alignment. This let's us nicely position our timer in the upper right corner of the game.</p>
<p><img src="./img/c06-timer.jpg" alt="gameplay with Time Left reading 10 seconds" /></p>
<p>[section summary]</p>
<h2 id="restart-grace-period"><a class="header" href="#restart-grace-period">Restart Grace Period</a></h2>
<h2 id="refactor"><a class="header" href="#refactor">Refactor</a></h2>
<ul>
<li>fire input</li>
<li>game over method</li>
<li>FPS constant</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-control"><a class="header" href="#source-control">Source Control</a></h1>
<p>When working on any piece of software, whether it's a video game or an app to track how dogs you pet in a given day, it's extremely important to keep track of the changes to your code and keep it backed up in a secure location.</p>
<p>Imagine this scenario: you work on your game for three months. It's amazing. It's your X-Files Dating Sim. You've painstakingly drawn all of the characters, written the scenario, coded up all the interactions. Then one day your computer gets stolen by a giant crow! I don't trust those crows, I never have. Suddenly your game is gone, poof. All that hard work just sitting on a hard-drive barely being protected by the shell of your laptop from the aggressive pecks of the entire local union of crows.</p>
<p>You'd just have to start over, from scratch. That is if you aren't too bummed out about losing the entire game. Crow theft--it's the number one reason to back up your game's source code.</p>
<h2 id="back-up-your-game"><a class="header" href="#back-up-your-game">Back Up Your Game</a></h2>
<p>You could use a cloud service like Dropbox to back it up to the ‚ú®cloud‚ú®. That's better than nothing. Then when you get a new computer because, you know, the crows stole your other one, you'll be good to go. Your game will be backed up. Heck, Dropbox does it automatically. That's pretty nifty.</p>
<h2 id="using-git"><a class="header" href="#using-git">Using Git</a></h2>
<p>I'd like to advocate for using source control (a.k.a. version control) to keep track of the changes to your game. It's like a more advanced form of using a cloud storage provider. The primary source control tool is called <a href="https://git-scm.com/">Git</a>. Git lets you track your changes by creating commits--references of what changed and why since the last time you made a commit.</p>
<p>The basics of Git are beyond the scope of this book, but there are some helpful resources out there:</p>
<ul>
<li><a href="https://git-scm.com/doc">Git's Documentation</a></li>
<li><a href="https://github.com/git-guides">GitHub's Git Guide</a></li>
<li><a href="https://git-scm.com/downloads/guis">GUI apps for working with Git</a></li>
</ul>
<p>Using version control at first may seem a bit tedious, but it's immensely valuable. Not only can you document why you made a change to help your future self and others, but you can safely experiment without fear of really messing things up. Because you're tracking the changes to your game's source, if you go down a rabbithole that doesn't work out, you can easily undo it. Let's explore some examples of commits and scenarios where it's helpful.</p>
<p>Any time you add a feature, create a commit. This lets you see your game evolve over time. Let's say you added player input with the gamepad. Boom, make a commit! Let's say you improved the enemy AI, commit that. Keep your commits small. Don't make hundreds of lines of unrelated changes and make a big commit that just say &quot;changed some stuff&quot;. You're trying to help yourself but creating a useful log of your game. Here's a look at commits from a little project of mine:</p>
<pre><code class="language-console">commit 9a74acdbec6971fab76fd81b2d78526ffef2c621
Date:   Thu Nov 24 07:22:15 2022 -0500

    Add score tracking

commit c5c277eae786100609b7dfbc9a516e44b705f59b
Date:   Thu Nov 24 07:16:24 2022 -0500

    add bullet &amp; enemy collision

commit 35aba8938b0e1afd7888ca09f6693330307facb6
Date:   Thu Nov 24 06:59:45 2022 -0500

    Rename project

commit 357b0412b24d805f49a1c542564ec76fe2962b7a
Date:   Thu Nov 24 06:59:25 2022 -0500

    Delete dead enemies from collection

commit 967fd73886e298394c1f923280bbdfb7f7cfa778
Date:   Thu Nov 24 06:53:27 2022 -0500

    swap player &amp; enemy sprite; revise bullet sprite

commit 2a233f7248d03cd8c602158acd9b1899b3ee8429
Date:   Wed Nov 23 23:04:46 2022 -0500

    add simple bullet firing
</code></pre>
<p>Any time I add, change, or fix functionality, I make a commit. This lets me easily see my changes.</p>
<p>The flow of development is:</p>
<ol>
<li>Write code to make the game do something</li>
<li>Test the changes out in the game</li>
<li>Adjust the code</li>
<li>Test the adjustments</li>
<li>Create a commit</li>
</ol>
<p>Start the flow again!</p>
<h2 id="source-code-hosts"><a class="header" href="#source-code-hosts">Source Code Hosts</a></h2>
<p>When you use Git on your computer for your project, you're creating a log of changes that exists in your computer. You'll want to push your Git repository up to a host so that it's backed up. There are many free hosts out there, allowing you to create private or public repositories of your code. </p>
<p>Some popular ones are:</p>
<ul>
<li><a href="https://github.com">GitHub</a></li>
<li><a href="https://bitbucket.org/">Bitbucket</a></li>
<li><a href="https://about.gitlab.com/">GitLab</a></li>
</ul>
<p>In the flow of development above, step 6 is: push the code to the remote host. This ensures those pesky crows can't totally steal your game and you'll live to code another day.</p>
<h2 id="using-source-control-with-dragonruby-game-toolkit"><a class="header" href="#using-source-control-with-dragonruby-game-toolkit">Using Source Control with DragonRuby Game Toolkit</a></h2>
<p>When I work on my DRGTK games, I check the entire project, including the engine, into source control. This lets me easily clone and run the project without needing to set anything up. Because the engine binary (<code>./dragonruby</code>) is so small, it's no problem at all. I'll often clean out the sample code and sprites if I'm not going to use them.</p>
<p>A benefit to this is that if a new version of DRGTK is released, I can create its own commit for that and easily rollback if anything breaks. Phew!</p>
<h2 id="a-note-on-open-source-dragonruby-game-toolkit-games"><a class="header" href="#a-note-on-open-source-dragonruby-game-toolkit-games">A Note on Open Source DragonRuby Game Toolkit Games</a></h2>
<p>You may have heard of the term open source software (OSS). It's when people write code and release available to the public to see and use under varying license terms. Code is released as open source for a variety of reasons, from helping people learn to collaborating with anyone. It allows people to contribute and help fix things. This book is even <a href="https://github.com/DragonRidersUnite/book">open source</a>!</p>
<p>The DragonRuby Game Toolkit is not open source software, which means that you can't distribute the engine publicly on a source control host, but you can publish the code you've written, since it's your code. This is a bit a nuanced situation with DRGTK because of how projects work.</p>
<p>I recommended checking the entire folder of the engine and your game into source control in the previous section. But if you want to open source your game, I'd do it a little differently. And it helps to know this from the start of your project, but it's okay if you do it later down the line.</p>
<p>If you want to open source you game, follow these steps:</p>
<ol>
<li>Unzip the engine</li>
<li>Change into the <code>mygame</code> directory</li>
<li>Initialize your Git repository there with <code>git init</code></li>
<li>Don't track the engine parent folder</li>
</ol>
<p>The downside to this approach is that you need to ensure you keep your specific engine version parent directory available. You could use version control to sync that and then use Git to publish it online as open source code.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<ul>
<li>Back up your games! You never know when you might lose your computer.</li>
<li>Source control, like Git, let's you make changes with confidence.</li>
<li>Push your code regularly to a source control host so that it's backed up.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-dev-resources"><a class="header" href="#game-dev-resources">Game Dev Resources</a></h1>
<p>While this book covers the technical aspects of programming games with Ruby, there is a lot more to making games than just coding. This bonus chapter includes resources and information to help you make your games your own.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<h3 id="audio"><a class="header" href="#audio">Audio</a></h3>
<ul>
<li>Sfxr</li>
<li>Audacity</li>
<li>1BitDragon</li>
</ul>
<h3 id="graphics"><a class="header" href="#graphics">Graphics</a></h3>
<ul>
<li>Aseprite</li>
</ul>
<h2 id="game-design"><a class="header" href="#game-design">Game Design</a></h2>
<ul>
<li>Juice video</li>
<li>jw game feel vid</li>
</ul>
<h2 id="books"><a class="header" href="#books">Books</a></h2>
<ul>
<li>How To Make a Game By Yourself</li>
<li>From Dream to Delivery</li>
<li>Spelunky book</li>
</ul>
<h2 id="youtube-videos"><a class="header" href="#youtube-videos">YouTube Videos</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
