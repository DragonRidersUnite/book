<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Games with DragonRuby</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A comprehensive guide to shipping cross-platform 2D games with ease using DragonRuby Game Toolkit.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="01-hello-dragon.html"><strong aria-hidden="true">1.</strong> Hello Dragon!</a></li><li class="chapter-item expanded "><a href="02-player-movement.html"><strong aria-hidden="true">2.</strong> Player Movement</a></li><li class="chapter-item expanded "><a href="03-spit-fire.html"><strong aria-hidden="true">3.</strong> Spit Fire</a></li><li class="chapter-item expanded "><a href="04-target-practice.html"><strong aria-hidden="true">4.</strong> Target Practice</a></li><li class="chapter-item expanded "><a href="05-fireball-clean-up.html"><strong aria-hidden="true">5.</strong> Fireball Clean Up</a></li><li class="chapter-item expanded "><a href="06-time-attack.html"><strong aria-hidden="true">6.</strong> Time Attack</a></li><li class="chapter-item expanded "><a href="07-high-score.html"><strong aria-hidden="true">7.</strong> High-Score</a></li><li class="chapter-item expanded "><a href="08-sound.html"><strong aria-hidden="true">8.</strong> Sound</a></li><li class="chapter-item expanded "><a href="09-background.html"><strong aria-hidden="true">9.</strong> Background</a></li><li class="chapter-item expanded "><a href="10-animation.html"><strong aria-hidden="true">10.</strong> Animation</a></li><li class="chapter-item expanded "><a href="11-scenes.html"><strong aria-hidden="true">11.</strong> Scenes</a></li><li class="chapter-item expanded "><a href="12-ship-it.html"><strong aria-hidden="true">12.</strong> Ship It!</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="outro.html">Outro</a></li><li class="chapter-item expanded affix "><a href="ruby-primer.html">Ruby Primer</a></li><li class="chapter-item expanded affix "><a href="beyond-the-code.html">Beyond the Code</a></li><li class="chapter-item expanded affix "><a href="dragonruby-resources.html">DragonRuby Resources</a></li><li class="chapter-item expanded affix "><a href="game-dev-resources.html">Game Dev Resources</a></li><li class="chapter-item expanded affix "><a href="source-control.html">Source Control</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Building Games with DragonRuby</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/DragonRidersUnite/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="./img/cover.jpg" alt="cover of Building Games with DragonRuby, with the subtitle 'A comprehensive guide to shipping cross-platform games with ease' by Brett Chalupa and the Dragon Rider Community." /></p>
<p>üöß <em>Building Games with DragonRuby</em> is a work in progress. Expect typos, issues, and incompleteness. üöß</p>
<p>This book is aimed at new game developers who are interested in learning to code and build games. If you've written code before, especially Ruby, then you'll have a bit of a headstart. But the concepts in this book are beginner friendly. Whether you're new to game dev or just DragonRuby Game Toolkit, you'll have made a finished game by the end of this.</p>
<p>You need no prior experience with programming or game making to follow this book.</p>
<h2 id="why-learn-how-to-make-games"><a class="header" href="#why-learn-how-to-make-games">Why Learn How to Make Games</a></h2>
<p>Making games is a total blast. It's challenging but rewarding. They're the sum total of so many creative mediums, <em>plus</em> they're interactive. You'll learn so many different skills by making games:</p>
<ul>
<li>Programming and logic</li>
<li>Rendering images</li>
<li>Responding to input</li>
<li>Game design</li>
<li>Interactive design</li>
<li>Working with image files</li>
<li>Editing audio files</li>
<li>Distributing the game software to users</li>
<li>Getting feedback from your game and iterating</li>
</ul>
<h2 id="about-dragonruby-game-toolkit"><a class="header" href="#about-dragonruby-game-toolkit">About DragonRuby Game Toolkit</a></h2>
<p><a href="https://dragonruby.org/toolkit/game">DragonRuby Game Toolkit</a> (DRGTK) is a cross-platform game engine for building 2D games. It lets you write games in Ruby, a wonderfully expressive and approachable language. It allows game developers to quickly iterate on their games and ship them to any modern platform.</p>
<p>DRGTK is <strong>not</strong> a no-code engine. You'll write the code that your game runs. This may seem scary at first, but it's a lot of fun and really powerful. Making games is also a great way to learn how to code! Don't know Ruby? That's okay, this book will teach you what you need to know.</p>
<h3 id="but-it-isnt-free"><a class="header" href="#but-it-isnt-free">But it isn't free!</a></h3>
<p>DRGTK costs money, yes. And there are plenty of free game engines out there. But the DRGTK team is committed to sustainably working on the engine and making it the best it can be, which means they need to get paid for their work. Support small teams by buying their software, it shows you're interested and it helps them keep doing what they love.</p>
<p>You're investing in the engine and ecosystem, quite literally, by buying DRGTK. I want to see it succeed, so I bought a license. I want to see it succeed so badly I've written this book to try to help <em>you</em> make games with it.</p>
<p>Plus, if you're a student or in need of financial assistance, the DragonRuby team offers free licenses. <a href="https://dragonruby.org/toolkit/game">Get in touch with the team to get a free license.</a></p>
<p>There's also <a href="fiddle.dragonruby.org">a free, interactive environment</a> you can use to sample DragonRuby GTK. Give it a try and see what you think!</p>
<h2 id="why-dragonruby-toolkit"><a class="header" href="#why-dragonruby-toolkit">Why DragonRuby Toolkit</a></h2>
<p>There are more game engines, frameworks, and libraries than I can count on my hands and toes. So why should you use DragonRuby?</p>
<p>That's a legit question. Here are my reasons why:</p>
<ul>
<li>It's focused on 2D games, so there's no competing interests in how the tooling works. It means what you need to know is pretty simple and easy to remember.</li>
<li>It allows building games for all modern platforms, from desktop computers to the web to mobile devices to consoles. It's truly cross-platform and <em>just works</em>, which is amazing.</li>
<li>It's fast a heck, which is important for making quality games.</li>
<li>It makes use of Ruby, which is a wonderfully productive programming language.</li>
<li>It doesn't force you to use a specific editor or tooling.</li>
<li>It's lightweight to run the engine, which is great. Everything runs fast.</li>
<li>It has live-reload and no compile times, which means when you change your game code, it automatically refreshes in the running engine. This is honestly so amazing, that you wouldn't know it unless you've used other game engines that require you to start a new build with each change.</li>
</ul>
<p>I'm going to be honest, DRGTK might not be for you. If you want to make 3D games, look elsewhere. Although, if you're new to game development, I wouldn't recommend starting with a 3D game. If you're absolutely not willing to try coding, look elsewhere.</p>
<p>But for everyone else, I think DRGTK will knock your socks off (or at least shift them down a little).</p>
<h2 id="mindset"><a class="header" href="#mindset">Mindset</a></h2>
<p>When learning something new, especially something that's challenging, it's important to have the right mindset.</p>
<ul>
<li>Be curious: it's the best way to learn!</li>
<li>Be patient: learning is difficult, but stick with it</li>
<li>Be kind: to yourself and others</li>
</ul>
<p>When we learn how to play a new instrument, we learn the basics by covering simplistic pieces of music. Similarly, we're going to &quot;cover&quot; simpler game mechanics to get you started. Before long, you'll grasp the basics and be able to move onto more complex games and mechanics.</p>
<p>Start by making small games that you can finish in a couple of days. Make a lot of small games to learn quickly. Don't get too wrapped up in your dream idea or making something that gets on Steam. Definitely don't try to make an MMORPG. Instead, focus on <strong>shipping</strong> your small games.</p>
<p>What's shipping? Isn't that when you want Mulder and Scully to kiss? No! Get your head out of the gutter you alien-loving freak. (I want to believe! üõ∏) Shipping is when you 1. finish your game and 2. release it for people to play it.</p>
<p>So here's your mindset, really, boiled down: make a small game and ship it for free, then make another small game and ship it for free. Before long, you'll be building a visual novel where Mulder and Scully kiss and be swimming in a pool of cryptocoins! But seriously, what that mindset will do is help you grow as a developer, build an audience, and get your shipping muscle primed and ready for making a better game with each one.</p>
<h2 id="what-well-be-making"><a class="header" href="#what-well-be-making">What We'll Be Making</a></h2>
<p>Throughout the book, we'll be building a simple shoot-'em-up where you pilot a dragon. You'll learn all of the foundation aspects of making a game:</p>
<ul>
<li>The game loop</li>
<li>Rendering text</li>
<li>Rendering sprites and animating them</li>
<li>Handling input</li>
<li>Enemies and AI</li>
<li>Playing sound effects and music</li>
<li>Polishing your game</li>
<li>Shipping it!</li>
</ul>
<p>TODO: playable demo link</p>
<h2 id="hold-the-gosh-dang-phone"><a class="header" href="#hold-the-gosh-dang-phone">Hold the Gosh Dang Phone</a></h2>
<p>&quot;Who the heck are <em>you</em>?&quot; you might be shouting at your screen. Little ole me? I'm just the voice of the dragon that lives within all beings! No, no, I kid. I'm Brett! I'm a programmer who enjoys making games and sharing what I've learned along the way.</p>
<p><img src="./img/brett.png" alt="pixel avatar of Brett" /></p>
<p>That's-a-me! If I was a bunch of pixels I guess.</p>
<p>I love Ruby. I've been writing it for over 12 years, and it's such a joy. I also love games. Particularly 2D games. So here we are. ‚ù§Ô∏èüíé + üéÆ = üìï How's that for an equation?!</p>
<p>I don't know, you want me to be serious about why you should listen to me? Oh you skipped this section, okay fine. Wow, did you drop that banana peel there? You trying to take me out already? This early in the book? Well, I'll see you in the next chapter! We'll see who gets the last laugh.</p>
<h2 id="why-the-book-is-free"><a class="header" href="#why-the-book-is-free">Why the Book is Free</a></h2>
<p>When I was 16, I took a computer science class in high school. It was my first exposure to programming with a language more complex than HTML and CSS. We programmed in Java. My teacher had us print out our assignments for grading (for some odd reason).</p>
<p>That class was foundational in the course my life would take in the 14 years since. At age 16 I was an emo kid who loved video games. Imagine a swoopy haired teen in their bedroom listening to Bright Eyes while playing <em>Final Fantasy XII</em>. That was me.</p>
<p>So naturally, for my final project in that high school computer science class I made a game. You pilot a Moltres from Pokemon who shots fire balls at Zaku mechs from Gundam that fly across the screen. If you get hit by an enemy, it's game over. If you defeat all of the enemies, you win. This game was lovingly titled <em>Zaku Space Battle</em>.</p>
<p><img src="./img/zaku-space-battle.jpg" alt="screenshot of Zaku Space Battle showing the Moltres sprite, Zaku sprites, fire ball, and space background" /></p>
<p>In order to make that game, I followed a free online tutorial that laid out the foundations of making a game with Java. There was no way I would have figured out on my own how to make a game at that point without help from a free online tutorial. I had <em>so</em> much fun making that final project that I went to college to study game programming and do programming for my career. I took what I learned in that tutorial, expanded the functionality, and made it my own (with copyright sprites, but still!).</p>
<p>This book is freely accessible so that someone who loves games and wants to try making them can do so. Free programming resources have truly shaped my life and career. I wouldn't have the life and career I have now without them. So I want to give back and try to help other aspiring developers.</p>
<p>You'll learn the foundations of game programming and making games, as well as some more advanced topics. If this book can help even just one person start and finish a game, it's worth every minute I've spent on it. We'll make a game not too dissimilar from <em>Zaku Space Battle</em>. Once you finish it, take what you've learned and make it your own!</p>
<p>If you want to, you can <a href="https://buymeacoffee.com/brettchalupa">send me a tip</a> as a way of saying thank you. It's much appreciated.</p>
<h2 id="contribute"><a class="header" href="#contribute">Contribute</a></h2>
<p>This book is open source. That means anyone can view the code that builds it and contribute toward making better. Did you find something that doesn't work, a typo, or lacks clarity? <a href="https://github.com/DragonRidersUnite/book">Submit an issue or contribute on GitHub.</a> It's easy, and you can do it right from your browser. Thanks in advance!</p>
<p>If you're stuck and would like some extra assistance, reach out in <a href="https://discord.dragonruby.org">the DragonRuby Discord</a>. We'll get you unstuck!</p>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<p>All right, are you ready to make a game? Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-dragon"><a class="header" href="#hello-dragon">Hello Dragon!</a></h1>
<p>We'll start by rendering an image and some simple text on the screen. But first, we need to get our computer and DragonRuby Game Toolkit ready for developing.</p>
<h2 id="first-steps"><a class="header" href="#first-steps">First Steps</a></h2>
<ol>
<li><strong>Download a code editor:</strong> Since you'll be coding your game, you need a special text editor to let you write the code without any extra formatting that text editors like Microsoft Word add. <a href="https://code.visualstudio.com/">Visual Studio Code</a> is a great free editor. Download and install it. (Or use your own favorite editor.)</li>
<li><strong>Get DragonRuby GTK:</strong> You need to get a copy of DragonRuby GTK so you can use the engine. <a href="https://dragonruby.itch.io/dragonruby-gtk/purchase">Buy it on Itch and download the zip file for your operating system.</a></li>
<li><strong>Extract the DRGTK engine zip</strong>: In your computer's file explorer, extract the engine zip file.</li>
</ol>
<p>You're ready to work on your game. Let's get to it!</p>
<p><strong>ProTip:</strong> don't delete the zip file! You can unzip it again for when you start working on your next game. It's helpful to keep it around.</p>
<h2 id="whats-in-the-engine-zip"><a class="header" href="#whats-in-the-engine-zip">What's in the Engine Zip</a></h2>
<p>When you download DragonRuby Game Toolkit, it contains everything you need to build your game. There's no external dependencies to install or monkey with. You just use the provided files and start making your game.</p>
<p>Let's go over the key files in the archive you just extracted:</p>
<ul>
<li><code>dragonruby</code> ‚Äî the executable you'll run to launch your game in development mode, you're primary entry into the development flow</li>
<li><code>dragonruby-publish</code> ‚Äî a command-line tool to help you easily build and publish your game online, don't worry about this yet!</li>
<li><code>samples/</code> ‚Äî a folder of example code that you can run if you'd like, or just ignore it for now</li>
<li><code>docs/</code> ‚Äî the DragonRuby Game Toolkit docs for the version you've downloaded, extremely handy if you want to dive deeper than this book</li>
<li><code>mygame/</code> üåü ‚Äî as the name implies, this is where the code, graphics, sound, and other assets live for your game; this is the primary folder you'll be working in
<ul>
<li><code>app/</code> ‚Äî this is where your Ruby code goes
<ul>
<li><code>main.rb</code> ‚Äî this is the main file for your game code, don't worry about the other two yet</li>
</ul>
</li>
<li><code>data/</code> ‚Äî where you can put any data for your game, like level editor files</li>
<li><code>fonts/</code> ‚Äî where fonts go, duh!</li>
<li><code>metadata/</code> ‚Äî configuration files for your game, we'll do more here later</li>
<li><code>sounds/</code> ‚Äî where music and sound effects go</li>
<li><code>sprites/</code> ‚Äî where images go that will be rendered in the game; there are already some simple ones to work with by default</li>
</ul>
</li>
</ul>
<p>Don't worry about the other files yet. Focus on the <code>mygame/</code> directory, and, specifically, <code>mygame/app/main.rb</code>.</p>
<h2 id="start-the-game"><a class="header" href="#start-the-game">Start the Game</a></h2>
<p>Launch the <code>dragonruby</code> file.</p>
<p>If you're on MacOS, right-click the file and select &quot;Open&quot;. You'll need to ensure software from unverified sources can be installed.</p>
<p>Here's what gets displayed:</p>
<p><img src="./img/hello-world.jpg" alt="screenshot of the Hello World! for DragonRuby GTK" /></p>
<p>This isn't a game... yet! But it is doing three key things:</p>
<ol>
<li>Launching an app window</li>
<li>Rendering text</li>
<li>Displaying an image</li>
</ol>
<p>And you haven't even written any code yet. Not a bad starting place.</p>
<p>DRGTK handles the unfun stuff of making games‚Äîdealing with low-level APIs like graphics, window, and sounds. We can instead focus on making our game.</p>
<h2 id="an-overview-of-the-main-game-file"><a class="header" href="#an-overview-of-the-main-game-file">An Overview of the Main Game File</a></h2>
<p>Let's take a look at what's in <code>mygame/app/main.rb</code>:</p>
<pre><code class="language-ruby">def tick args
  args.outputs.labels  &lt;&lt; [640, 500, 'Hello World!', 5, 1]
  args.outputs.labels  &lt;&lt; [640, 460, 'Go to docs/docs.html and read it!', 5, 1]
  args.outputs.labels  &lt;&lt; [640, 420, 'Join the Discord! https://discord.dragonruby.org', 5, 1]
  args.outputs.sprites &lt;&lt; [576, 280, 128, 101, 'dragonruby.png']
end
</code></pre>
<p>You can open this file yourself in Visual Studio Code. Go ahead and do that: New Window &gt; Open &gt; [select the folder on your computer with the engine in it]</p>
<p>Six lines of codes to render text and an image? Not bad! (Trust me, if you did this all from scratch without an engine, it'd take at least hundreds of lines of code.)</p>
<p>Here's what that code does, line by line:</p>
<pre><code class="language-ruby">def tick args
</code></pre>
<p>This <code>def</code>ines a method called <code>tick</code> and passes in an argument called <code>args</code>. Methods are reusable pieces of code that you can call to do something over and over again. Think of methods like verbs; they're actions. Methods are a foundational building block of code that allow for code reuse.</p>
<p>Let's say you wanted to give a friend a cookie üç™, you'd define a method called <code>give_cookie</code> and pass in the <code>friend</code> as a parameter.</p>
<pre><code class="language-ruby">def give_cookie(friend)
  friend.eat(:cookie)
end
</code></pre>
<p>You'd then call that method like:</p>
<pre><code class="language-ruby">francis = Friend.new
give_cookie(francis)
</code></pre>
<p>Wait, how'd we get talking about cookies and friends? Okay, back to the code above.</p>
<p><code>args</code> is a bunch of data that gets passed into <code>tick</code> whenver it is called. We'll learn more about <code>args</code> soon.</p>
<p>The next three lines handle outputting text to the screen:</p>
<pre><code class="language-ruby">args.outputs.labels  &lt;&lt; [640, 500, 'Hello World!', 5, 1]
args.outputs.labels  &lt;&lt; [640, 460, 'Go to docs/docs.html and read it!', 5, 1]
args.outputs.labels  &lt;&lt; [640, 420, 'Join the Discord! https://discord.dragonruby.org', 5, 1]
</code></pre>
<p>Your eyes might be melting a little bit. But don't worry, wipe that melted bit of eye away and focus! It's actually pretty intuitive once you get the hang of it.</p>
<p>Remember <code>args</code> from above? That parameter that's passed into <code>tick</code>? Well, you can call methods on it! This allows you to interact with the game engine.</p>
<p><code>args</code> has a method called <code>outputs</code> that represents the data that gets rendered in the screen. You access it with <code>args.outputs</code>. Neato! <code>labels</code> is a method on <code>outputs</code>, see how the <code>.</code> chains things together?</p>
<p>The <code>&lt;&lt;</code> is called the shovel operator. It lets you push data into a collection. <code>labels</code> is the collection we're shoveling data into because we want to render some text.</p>
<p>And then finally the code within the brackets <code>[]</code> is an array of data that represents what we want to display on the screen. It may not be clear exactly what it's doing yet, but it'll become more clear over time.</p>
<p>[TODO: array illustration]</p>
<p>You can see some code in quotes, those are strings. And they're what's being displayed by the game. In order to show the text, though, we need to tell the engine where to place it on the screen. That's what the first two elements of the array do: they specify the x and y position in of the text in the game. Then there's the text we want to render. That's followed by the size. Then finally the alignment (centered in this case).</p>
<p>Here's it broken down:</p>
<pre><code class="language-ruby">#  x,   y,           text, size, alignment
[640, 500, 'Hello World!',    5,         1]
</code></pre>
<p>Don't worry about memorizing what the positional elements of the array mean. This is just a quick way to render text. We'll start using a more friendly approach soon enough. The sample game does this three times, thus rendering three difference pieces of text. The <code>y</code> coordinate is different for each, stacking them on top of each other vertically instead of overlapping one another.</p>
<p>Gosh enough of this rambling, let's adjust some code. Change the text from <code>&quot;Hello World!&quot;</code> to be <code>&quot;Hello Dragon!&quot;</code> and save the file.</p>
<p><img src="./img/hello-dragon.jpg" alt="screenshot of the Hello Dragon! for DragonRuby GTK" /></p>
<p>Did you see that? The game reloaded your code and changed the text to be &quot;Hello Dragon!&quot; That was quick, wasn't it? That's one of the best parts of DRGTK‚Äîlive reloading of your game code in the engine. This allows you to make changes to your game quickly, reducing the time between the cycles of writing your code and testing it.</p>
<pre><code class="language-ruby">args.outputs.sprites &lt;&lt; [576, 280, 128, 101, 'dragonruby.png']
</code></pre>
<p><code>args.outputs.sprites</code> is like labels, but it's instead a collection for sprites. It renders the <code>&quot;dragonruby.png&quot;</code> image at x: 576, y: 280, just like label text, but it also sets the size of the image to display. That's what the <code>128</code> and <code>101</code> represent in the array. Here's a break down of those elements:</p>
<pre><code class="language-ruby">#  x,   y,   w,   h,            image
[576, 280, 128, 101, 'dragonruby.png']
</code></pre>
<p>Just like with labels, don't worry about memorizing the order here. There are friendlier ways to display them that we'll get to shortly.</p>
<p>But it's an easy enough bit of code for putting an image on the screen.</p>
<p>Dragon sprite created by <a href="https://twitter.com/MobyPixel">Nick Culbertson</a>.</p>
<p>Finally, the last line:</p>
<pre><code class="language-ruby">end
</code></pre>
<p>signifies that the definition of the <code>tick</code> method is over. Any code after that isn't part of the <code>tick</code> method. That's it for what we get out of the box.</p>
<h2 id="screen-coordinates-explained"><a class="header" href="#screen-coordinates-explained">Screen Coordinates Explained</a></h2>
<p>Let's take a detour down Screen Coordinates Road. The <code>x</code> and <code>y</code> position are coordinates on the two-dimensional plane of the game window. Remember geometry? I barely do. But this is important, so don't doze off on me yet, we're only in the first chapter still!</p>
<p>[TODO: coordinates illustration]</p>
<p>DRGTK games are made up of a window that's 1280x720 pixels large. That's 1280 pixels wide and 720 pixels tall. The rectangle of the game screen is 921600 pixels, that's those two numbers multiplied. Each of those pixels has a coordinate on the plane. It makes it easy to refer to a specific pixel by using its <code>x</code> and <code>y</code> position.</p>
<p>DRGTK starts 0, 0 in the lower left. So 1280, 720 would be the upper right. <strong>Note:</strong> this varies from most game engines and libraries and tools, but it's intentional to make it easier to think about gravity and the geometric 2D plane that is taught in mathematics.</p>
<p>It's important to keep coordinates in mind, as we'll be using them a lot when making our game. A major aspect of games is moving things on the screen, which we do by changing their coordinates on the plane.</p>
<h2 id="our-own-hello"><a class="header" href="#our-own-hello">Our Own Hello</a></h2>
<p>Back to making the game. Okay, yeah, you changed a string and it changed what was rendered. That's neat. But let's bump it up a notch.</p>
<p>I want you to delete the code in <code>mygame/app/main.rb</code>. Select it all and delete it. Yup, I know, the blank canvas is a challenge. But you need to start writing the code yourself in order to learn and build the muscle memory. So go ahead and type out each line below into your <code>main.rb</code>.</p>
<p>[TODO: hand-write it, don't copy it illustration]</p>
<pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; [120, 120, &quot;Hello Dragon!&quot;]
end
</code></pre>
<p>You know what that does, right? Well you saw it automatically reload in your game, so of course you do!</p>
<p>Let's greet our friend Oboe too.</p>
<pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; [120, 120, &quot;Hello Dragon!&quot;]
  args.outputs.labels &lt;&lt; [120, 100, &quot;Hello Oboe!&quot;]
end
</code></pre>
<p>Wow, so many friends we're saying hello to! The thing is... that code is a bit... duplicative. Let's write our own method to clean that up:</p>
<pre><code class="language-ruby">def greet friend
  &quot;Hello #{friend}!&quot;
end

def tick args
  args.outputs.labels &lt;&lt; [120, 120, greet(&quot;Dragon&quot;)]
  args.outputs.labels &lt;&lt; [120, 100, greet(&quot;Oboe&quot;)]
end
</code></pre>
<p>The new code refactors (changes the implementation of the code without changing the behavior) the original so that we can easily change the greeting in one place instead of many. This is a bit of a trivial example, but it shows how we can write our own methods in DRGTK to make our code better. Reusing code is foundational for the rest of this book.</p>
<p>The <code>&quot;Hello #{friend}!&quot;</code> code does what's called string interpolation. It takes whatever <code>friend</code> is, hopefully a name as a string, and inserts it. It's pretty similar to this code: <code>&quot;Hello &quot; + friend + &quot;!&quot;</code>, but quite a bit friendlier to use. The <code>#{}</code> tells Ruby to run any Ruby code within those curly braces.</p>
<p>Methods in Ruby return a value. Return values can then be used by the caller for whatever purposes are needed. In the example above, the return value is the string we build. Ruby returns the last line of the method definition automatically. But you can explicitly return early with <code>return</code>, which can be useful if you want to end the execution of a method early.</p>
<p>Go ahead and change the <code>#greet</code> method to:</p>
<pre><code class="language-ruby">def greet friend
  &quot;Hello #{friend}!&quot;
  1
end
</code></pre>
<p>Whoa! What happened to our greetings? Well, we changed our code and it now always returns <code>1</code>, which isn't what we want. It's just an example to illustrate how that works. Go ahead and undo that change.</p>
<p>Let's do one final thing in our hand-crafted, artisinal version of rendering text and images. Let's display a sprite. In <code>mygame/sprites/misc/</code> there's a file named <code>dragon-0.png</code>. It's a pixel art dragon made by Nick Culbertson that's free to use. Pretty neat!</p>
<pre><code class="language-ruby">def greet friend
  &quot;Hello #{friend}!&quot;
end

def tick args
  args.outputs.labels &lt;&lt; [120, 120, greet(&quot;Dragon&quot;)]
  args.outputs.labels &lt;&lt; [120, 100, greet(&quot;Oboe&quot;)]
  # Here's our new line
  args.outputs.sprites &lt;&lt; [120, 280, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p><img src="./img/hello-dragon-own.jpg" alt="screenshot of the Hello Dragon! with pixel dragon displayed" /></p>
<p>That's some pretty fine code for the first chapter. We've got text and an image displaying. We learned about methods too. Don't worry if it's not all making total and complete sense. You'll understand more with time. Remember, be patient.</p>
<h2 id="game-loop-explained"><a class="header" href="#game-loop-explained">Game Loop Explained</a></h2>
<p>There's a lot of magic happening where we can just write <code>def tick</code> and magically have a game. What's happening here is that DragonRuby Game Toolkit takes the code in <code>mygame/app/main.rb</code>, find the tick method, and then runs a loop that calls it 60 times every second until the program closes. This loop is referred to as the Game Loop.</p>
<p>When programming games, any number of things are happening at one time. Enemies are moving, images are being displayed, math is being calculated, input is being handled. The loop runs over and over again, accounting for any changes in the state of the game. This is similar to how screens on devices work‚Äîthey refresh so many times a second, so fast that it's barely perceptible to the human eye.</p>
<p>Within the game loop, we'll keep track of everything that's happening, update state, and render text and images. It's important to begin to think about things in a loop, as it influences timing and code structure.</p>
<p>[TODO: drawing of the game loop and why it matters]</p>
<p>The game loop will begin to feel more natural over time, but for now, remember this: <strong>DRGTK runs the <code>tick</code> method 60 times every second</strong>.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next</a></h2>
<p>Let's get the player dragon moving around on the screen when we press certain keys. Player input is foundational to making games and a great next step.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="player-movement"><a class="header" href="#player-movement">Player Movement</a></h1>
<p>In the last chapter, we got a dragon sprite showing up on the screen and some text. Let's build upon that by making it so we can control the dragon with our keyboard and a gamepad. Because guess what? That dragon is now the main character of this game we're building. üêâ Buckle up, it's dragon riding time.</p>
<p>Simplify <code>mygame/app/main.rb</code> to be just this for now:</p>
<pre><code class="language-ruby">def tick args
  args.outputs.sprites &lt;&lt; [120, 280, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>That displays our player dragon and nothing else. Excellent. Let's get this dragon moving!</p>
<p>In order to handle moving the player, we need to keep track of the position across the game loops. This lets us know where the player was last <code>tick</code>, check if they should move, and then update the position accordingly.</p>
<p>Update your <code>mygame/app/main.rb</code> to be this:</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>There are a couple of new things here:</p>
<ul>
<li><code>args.state</code></li>
<li><code>||=</code></li>
</ul>
<p>Let's start with <code>args.state</code>. It's basically a blob that can be anything you want it to be, a bit like Kirby. Feed it <code>player_x</code> and it keeps track of it. Whatever you feed the <code>args.state</code>, it'll be accessible in future ticks. Keeping track of game state across ticks is important! It's part of the game loop. If we don't know where the player last was, how can we calculate where they should move to? We need to keep track of it in someplace. <code>args.state</code> is a fine place to start.</p>
<p>You can define anything on <code>args.state</code>, so it's up to you to use useful names. You could make <code>args.state.bleh</code> and set it to your favorite color, <code>args.state.bleh = &quot;blue&quot;</code> or your age, <code>args.state.age = 30</code>. Much like Kirby, <code>args.state</code> doesn't care what you feed it. It's just hungry for your data.</p>
<p>In this case, we're feeding it <code>||= 120</code>. What the heck is <code>||=</code>? Well... Maybe we need to start with <code>=</code>. You might read that as &quot;equals&quot; but it's actually the assignment operator. It means: set the thing on the left to the value on the right. It's a core programming concept. It's useful for assigning data to properties that we want to keep track of.</p>
<pre><code class="language-ruby">name = &quot;Francis&quot;
</code></pre>
<p>That code assigns the string Francis to the variable name. Then we can use <code>name</code> to refer to that value. It may not seem useful quite yet, but it will soon enough.</p>
<p>You could then use that variable like this:</p>
<pre><code class="language-ruby">puts name
</code></pre>
<p>That calls a the <code>puts</code> method and passes our argument <code>name</code> to it. It prints whatever the value is out to the console. If you put that in your game code and press <kbd>~</kbd> to open the console, you'll see it print <code>&quot;Francis&quot;</code> a bunch.</p>
<p><code>||=</code> in English is &quot;or equals&quot;. That code above, <code>args.state.player_x ||= 120</code> would be read as: assign the property <code>player_x</code> on <code>args.state</code> the numeric value of 120 unless it's alreay assigned a value.</p>
<p>Remember how tick is running once every 60 seconds? We don't want to always set <code>args.state.player_x</code> to <code>120</code>. We just want to set it to that initially and then we'll update that value when we press keys on our keyboard or buttons on our gamepad. We haven't done that yet, but that's what's next.</p>
<p>Wow! That was a lot of explaination for two measly lines of code. But I'm telling ya', they're two really important lines of code when it comes to game programming.</p>
<p>Then, finally, we change the <code>x</code> and <code>y</code> value for the dragon sprite to be the value stored in <code>args.state</code> so that we can actually make use of that value instead of our hard-coded position before.</p>
<h2 id="checking-for-input"><a class="header" href="#checking-for-input">Checking for Input</a></h2>
<p>In <code>tick</code> we'll check to see if a given input is pressed. If it is, we'll change the sprite's x and y position accordingly.</p>
<p>Our ole buddy <code>args</code> has a little something known as <code>args.inputs</code>. This lets us check... inputs! Isn't programming nice? Most of the time the words used in programming make sense. But some of the time, they really don't, and it's a gosh dang nightmare. But let's commit right here, right now to trying to name things in a way that's useful. Okay, you're committed. When you name a method <code>def thingy</code>, you'll remember this. And your ears will ring a little bit and your eyes will get just a little dry and you'll remember that you broke this commitment.</p>
<p>Let's make use of <code>args.inputs</code>:</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280

  if args.inputs.left
    args.state.player_x -= 10
  elsif args.inputs.right
    args.state.player_x += 10
  end

  if args.inputs.up
    args.state.player_y += 10
  elsif args.inputs.down
    args.state.player_y -= 10
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>You can now control the dragon with WASD, the arrow keys, or your controller. Pretty neat! It's almost fun. All it took was 10 lines of code. Let's break them down.</p>
<pre><code class="language-ruby">if args.inputs.left
  args.state.player_x -= 10
elsif args.inputs.right
  args.state.player_x += 10
end
</code></pre>
<p>This section checks for horizontal movement. If the left input is pressed, reduce the player's x position by 10 pixels. <code>-=</code> means, subtract the value on the right from the value on the left. It's the same as <code>args.state.player_x = args.state.player_x - 10</code>, but it's much more concise. We increase <code>player_x</code> to move right, decrease it to move left.</p>
<p><code>if</code> and <code>elsif</code> are conditional checks. The code only runs if the value is true (more specifically, truthy, but let's not worry about that yet).</p>
<pre><code class="language-ruby">if args.inputs.up
  args.state.player_y += 10
elsif args.inputs.down
  args.state.player_y -= 10
end
</code></pre>
<p>Then we check for vertical movement. We add to <code>player_y</code> to move up, decrease it to move down.</p>
<p>What if we wanted our dragon to move faster though? We could change those four instances of <code>10</code> to be <code>12</code> and see how that feels, sure. But that's annoying to update it all over. Let's make use of a variable! We'll call it <code>speed</code>:</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  speed = 10

  if args.inputs.left
    args.state.player_x -= speed
  elsif args.inputs.right
    args.state.player_x += speed
  end

  if args.inputs.up
    args.state.player_y += speed
  elsif args.inputs.down
    args.state.player_y -= speed
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>Whoa! We just refactored that code. It's easier to change (ETC) now, which is a sign we're improving things.</p>
<h2 id="boundaries"><a class="header" href="#boundaries">Boundaries</a></h2>
<p>You can move your dragon completely off the screen, lost in the great unknown! This isn't ideal. Let's make it so our little buddy can't leave the bounds of the screen.</p>
<p>[TODO: drawing about boundaries]</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  speed = 12
  player_w = 100
  player_h = 80

  if args.inputs.left
    args.state.player_x -= speed
  elsif args.inputs.right
    args.state.player_x += speed
  end

  if args.inputs.up
    args.state.player_y += speed
  elsif args.inputs.down
    args.state.player_y -= speed
  end

  if args.state.player_x +  player_w &gt; args.grid.w
    args.state.player_x = args.grid.w - player_w
  end

  if args.state.player_x &lt; 0
    args.state.player_x = 0
  end

  if args.state.player_y + player_h &gt; args.grid.h
    args.state.player_y = args.grid.h - player_h
  end

  if args.state.player_y &lt; 0
    args.state.player_y = 0
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, player_w, player_h, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>Our dragon won't leave the screen. Woot woot! We've got some serious code here! Look at that logic. Here's what changed:</p>
<p>We moved the width and height of the player into variables so that they're easier to reference and reuse. Boom. We need those to do some math on the boundaries too. There's a general programming idea out there known as Don't Repeat Yourself (DRY). As soon as you have a piece of code, especially a number, that represents a value and is used multiple times, put it in a variable. This makes its intent clear as to what it represents and makes it easier to change. Win-win.</p>
<p>Here's the good stuff. We check the boundary for the x axis:</p>
<pre><code class="language-ruby">  if args.state.player_x +  player_w &gt; args.grid.w
    args.state.player_x = args.grid.w - player_w
  end

  if args.state.player_x &lt; 0
    args.state.player_x = 0
  end
</code></pre>
<p>We check the right side of the screen: if the current player's x position plus their width is greater than <code>args.grid.w</code>, then we set the x position to the width of the screen (<code>args.grid.w</code>) minus the width of the sprite. For example, if we move the sprite so it has the x position of 1284, 4 pixels past the right edge of the screen, we override that change and set it to 1280 minus the player's width.</p>
<p>It's so important that this happens after checking for input. You don't want to change <code>args.state.player_x</code> after this check, otherwise the boundary won't be enforced. Order matters with the code we write within <code>tick</code>.</p>
<p><code>args.grid.w</code> is the width of the screen. It's always 1280, but we don't want to have that magic number in our code. So we use <code>args.grid.w</code>.</p>
<p>Next we check the left side of the screen: if the player's x is less than 0, then we set it to zero. That's a bit similar to the right side, just simpler.</p>
<p>Then we do the same thing for the top and bottom of the screen by checking the y position.</p>
<h2 id="extra-credit"><a class="header" href="#extra-credit">Extra Credit</a></h2>
<ul>
<li>When you move the dragon horizontally and vertically at the same time, the dragon moves twice as fast. How could you make it so the dragon moves at a uniform speed still when that happens?</li>
</ul>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next</a></h2>
<p>In the next chapter we'll make our dragon spit fireballs when we press a key or button. Watch out!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spit-fire"><a class="header" href="#spit-fire">Spit Fire</a></h1>
<p>Our next mission is to make our dragon spit fire because that's just what they do. We'll piece this whole thing into a game with win and lose states, a narrative, and intentional design soon enough. But let's keep focusing on simple mechanics and the code for right now.</p>
<h2 id="fire-on-input"><a class="header" href="#fire-on-input">Fire on Input</a></h2>
<p>In the last chapter, we used <code>args.inputs</code> to check for player input from the four main directions. If those inputs were being pressed, then we moved the dragon. Now let's check to see if the <kbd>Z</kbd> key is pressed to know when to have our dragon spit a fireball.</p>
<p>To check if a key was pressed, we can use <code>args.inputs.keyboard.key_down</code> and then whatever key we want to check. So in our case, we'll check <code>args.inputs.keyboard.key_down.z</code>. In our <code>#tick</code> method, right above where we render the dragon sprite, let's check for that input:</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z
    puts &quot;Z key pressed&quot;
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, player_w, player_h, 'sprites/misc/dragon-0.png']
</code></pre>
<p>Using <code>puts</code> is a really helpful way to check that our game works as we expect it to. In this case, every tick where the Z key is pressed down, it prints the string &quot;Z key pressed&quot; to the console (open it iwth <kbd>~</kbd>, remember?). Run your game and press the Z key a bunch and then open your console.</p>
<img alt="screenshot of DragonRuby console showing Z key pressed 6 times" src="./img/c03-console-puts.jpg" style="max-width: 420px; width: 100%;">
<h2 id="expanded-control-support"><a class="header" href="#expanded-control-support">Expanded Control Support</a></h2>
<p>When making a game, it's important to support a variety of input configurations to make the game as accessible as possible. Sure, the keyboard arrow keys and the Z key are sensible defaults. But what if our player wants to use a gamepad controller? Or what if they would prefer to use WASD for movement? From the start of coding player input, let's support as many different inputs as reasonably possible.</p>
<p>In our case, we'll support three configurations:</p>
<ul>
<li>Arrow keys and Z</li>
<li>WASD and J</li>
<li>Gamepad</li>
</ul>
<p>DragonRuby GTK is a big help in this department. Our code earily that checks <code>args.inputs.up</code> (down/left/right) already checks for the arrow keys, WASD, and gamepad input. Slick! We don't have to change anything there. But let's go ahead and update our logic check for firing the fireball to check all of the possible inputs.</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    puts &quot;Spit fireball!&quot;
  end
</code></pre>
<p>We learned about <code>||=</code> earlier, and that's a combination of two separate operators in Ruby. <code>||</code> represents &quot;or&quot; and <code>=</code> says to assign a value. If the value on the left doesn't have a value, assign it the value on the right. We can make use of the &quot;or&quot; (<code>||</code>) operator independently of the assignment operator (<code>=</code>) to control the logic within our game.</p>
<p>The code above says: if the z key is down OR the j key is down OR the A button on the gamepad is pressed, then output the string to the console.</p>
<p>You can combine <code>||</code> on one line (<code>if monday || tuesday || wednesday</code>), but it can be helpful to break long lines to make our code easier to read.</p>
<p>Outputting info to the console isn't that helpful for the player, but can you begin to imagine how we'll use that check to instead display a fireball.</p>
<h2 id="displaying-fireballs"><a class="header" href="#displaying-fireballs">Displaying Fireballs</a></h2>
<p>We want to display a fireball on the screen when the action key is pressed. We've got most of the code, all we need to do is change <code>puts</code> to instead display the fireball.</p>
<p>At the top of <code>#tick</code> (<code>#name</code> is Ruby shorthand for &quot;the name method&quot;), assign an empty array to <code>args.state.fireballs</code> if nothing has been assigned yet. This will let us keep track of fireballs across the game loop to do all sorts of things with them (display them, move them, collide them with other objects):</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  args.state.fireballs ||= []
</code></pre>
<p>Then where we check for the action input, push a fireball into the <code>arg.state.fireballs</code> array based on the current player's x and y position:</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    args.state.fireballs &lt;&lt; [args.state.player_x, args.state.player_y, 'fireball']
  end

  args.outputs.labels &lt;&lt; args.state.fireballs

</code></pre>
<p>Then all we have to do is render our fireballs by pushing them into the <code>args.outputs.labels</code> collection. DragonRuby is smart enough to know that if we push an array into any <code>args.outputs</code> collection it'll flatten it and display them correctly. Thanks, DragonRuby!</p>
<p>Play your game and see what happens! Fireballs everywhere. Wait! You're not impressed by those fireballs? I'd be pretty frightened if the word fireball was flying at me.</p>
<p><img src="./img/c03-fireball-display.jpg" alt="screenshot of the game showing the word 'fireball' throughout with the dragon flying around" /></p>
<p>Wait, where are you going? Why are you muttering &quot;I didn't sign up to read no stinkin' book where you output the word fireball on the screen, I'm here for the real flame, the good stuff...&quot;</p>
<h2 id="moving-fireballs"><a class="header" href="#moving-fireballs">Moving Fireballs</a></h2>
<p>Guess what? We're sticking with ole &quot;fireball&quot; for now! It's silly and fun and I haven't found a good fireball sprite to use. We'll get there, we'll get there. But let's first make the fireballs move across the screen.</p>
<p>When we moved our player dragon, we took the x and y position and added or substracted values in each <code>#tick</code> based upon if any directional input was pressed. Our fireballs will move regardless of any button pressed once they're extruded from our ole dragon's mouth. Because our game is simple and the dragon only faces to the right, all of the fireballs will move to the right. How do we go about that on our X-Y axis? We just increase the <code>x</code> position of the fireball each tick. Let's do that and see what happens:</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    args.state.fireballs &lt;&lt; [args.state.player_x, args.state.player_y, 'fireball']
  end

  args.state.fireballs.each do |fireball|
    fireball[0] += speed + 2
  end

  args.outputs.labels &lt;&lt; args.state.fireballs
</code></pre>
<p>Right between where we add a new fireball to <code>args.state.fireballs</code> and we display them using <code>args.outputs.labels</code>, our new code does this:</p>
<ol>
<li>Loop through the array of <code>args.state.fireballs</code></li>
<li>For each fireball, update the array value at the <code>0</code> index, which is the x position of the fireball, to be the dragon's speed plus 2 (because we want the fireball to move faster than the dragon).</li>
</ol>
<p>Move your dragon around, spit some fire, and bask in the glory of a word moving so smoothly across the screen that it almost looks like a... fireball!</p>
<p>Try changing around <code>speed + 2</code> to make the fireballs move faster or slower and see how that feels. Adjusting speed values can really change the vibe of your game and is important in tuning it to feel just right.</p>
<p>There's a lot of important concepts in those three newly added lines of code. In Ruby, when there's an array of data, we can loop through <strong>each</strong> item and modify their properties. Games are composed of huge collections of things: enemies, fireballs, menu options, player inventory. Arrays (and just collections in general) aren't anything to be afraid of, and soon enough, you'll be thinking about your games in them.</p>
<p>Looping through an array of data in each <code>#tick</code> and then doing <em>something</em> is the stuff games are made of! Here are some ways this can be applied in all sorts of games: enemy behavior, checking for collision, animating. As our game (and any game you make) gets more complex, looping through collections of data becomes more and more common.</p>
<p>[TODO: illustration of game loop and then a little loop inside where we loop through collections]</p>
<h2 id="switching-to-hashes"><a class="header" href="#switching-to-hashes">Switching to Hashes</a></h2>
<p>So far throughout the book we've been using arrays to represent the entities in our game, whether it be the player's dragon sprite or our fireball text that gets displayed. Remember <code>[args.state.player_x, args.state.player_y, 'fireball']</code>? Arrays are wonderful and important, but they aren't so great for representing structured data because it's difficult to remember what each piece of data in the array's positions represents. Remembering that <code>fireball[2]</code> is the text value and not the y value is tricky. Luckily, DragonRuby has a more verbose and clear data structure we can use for managing our data. It's called a hash! Much like arrays, hashes are extremely useful.</p>
<p>Let's look at what the text example above would be like as a hash:</p>
<pre><code class="language-ruby">{
  x: args.state.player_x,
  y: args.state.player_y,
  text: &quot;fireball&quot;,
}
</code></pre>
<p>Hashes are expressed through curly braces <code>{}</code> and contain <code>key: value</code> pairs separated by commas. The values of a hash can be anything, from numbers to strings to whatever your heart desires. Let's say we wanted to build our own hash to represent a dragon and put it in the <code>dragon</code> variable:</p>
<pre><code class="language-ruby">dragon = {
  name: &quot;Francis&quot;,
  size: &quot;medium&quot;,
  age: 541,
}
</code></pre>
<p>Values of a hash are then accessed by their keys, so you <code>dragon.name</code> returns the string <code>&quot;Francis&quot;</code>, <code>dragon.size</code> returns the string <code>&quot;medium&quot;</code>, and <code>dragon.age</code> returns the number <code>541</code>. This is much more clear than having to remember the position of these values within an array.</p>
<p>Quick note: if you see a hash with key-value pairs that look like this: <code>{ :name =&gt; &quot;Francis&quot; }</code>, don't fret! That's just an older style in Ruby known as the hash rocket and can be used for hashes with keys that aren't just symbols.</p>
<p>In general, differentiate between arrays and hashes like this: <strong>hashes are used represent one piece of data with multiple properties</strong> and <strong>arrays are used to collect data (often times hashes) to keep track of and manipulate them</strong>.</p>
<p>Below is our entire game translated to use hashes instead of arrays for our rendering:</p>
<pre><code class="language-ruby">def tick args
  args.state.player ||= {
    x: 120,
    y: 280,
    w: 100,
    h: 80,
    speed: 12,
    path: 'sprites/misc/dragon-0.png',
  }
  args.state.fireballs ||= []

  if args.inputs.left
    args.state.player.x -= args.state.player.speed
  elsif args.inputs.right
    args.state.player.x += args.state.player.speed
  end

  if args.inputs.up
    args.state.player.y += args.state.player.speed
  elsif args.inputs.down
    args.state.player.y -= args.state.player.speed
  end

  if args.state.player.x +  args.state.player.w &gt; args.grid.w
    args.state.player.x = args.grid.w - args.state.player.w
  end

  if args.state.player.x &lt; 0
    args.state.player.x = 0
  end

  if args.state.player.y + args.state.player.h &gt; args.grid.h
    args.state.player.y = args.grid.h - args.state.player.h
  end

  if args.state.player.y &lt; 0
    args.state.player.y = 0
  end

  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    args.state.fireballs &lt;&lt; {
      x: args.state.player.x,
      y: args.state.player.y,
      text: 'fireball',
    }
  end

  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2
  end

  args.outputs.labels &lt;&lt; args.state.fireballs
  args.outputs.sprites &lt;&lt; args.state.player
end
</code></pre>
<p>It may not seem like much has changed, but there are two key changes that make this worthwhile:</p>
<ol>
<li><code>fireball.x += args.state.player.speed + 2</code> ‚Äî it is much clearer when we move the fireball that we're adding to its <code>x</code> position AND using the player's speed</li>
<li><code>args.outputs.sprites &lt;&lt; args.state.player</code> ‚Äî because we're keeping track of our player in <code>args.state.player</code> and it has the data DragonRuby needs to render it, we can just push it into <code>args.outputs.sprites</code> and not construct the array that we used to use</li>
</ol>
<h2 id="displaying-a-sprite"><a class="header" href="#displaying-a-sprite">Displaying a Sprite</a></h2>
<p>With that refactor done, let's display a sprite for our fireball and call it a chapter.</p>
<p>Download the fireball sprite below and put it in <code>mygame/sprites/fireball.png</code>:</p>
<p><img src="./code/chapter_03/06_sprite/sprites/fireball.png" alt="fireball sprite" /></p>
<p>We'll change the hash we push into <code>args.state.fireballs</code> to be a sprite and adjust how we render that collection. Nothing too major. Here's the changes near the bottom of <code>#tick</code> that you'll need to make:</p>
<pre><code class="language-ruby">  if args.inputs.keyboard.key_down.z ||
      args.inputs.keyboard.key_down.j ||
      args.inputs.controller_one.key_down.a
    args.state.fireballs &lt;&lt; {
      x: args.state.player.x + args.state.player.w - 12,
      y: args.state.player.y + 10,
      w: 32,
      h: 32,
      path: 'sprites/fireball.png',
    }
  end

  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2
  end

  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs]
</code></pre>
<p>We adjust the starting place of the fireball sprite to look like it comes out of the dragon's mouth. The sprite is 32 pixels wide by 32 pixes tall, so we set that.</p>
<p>Now that the fireball is a sprite and not a text label, we can push both the player and the array of fireballs into <code>args.outputs.sprites</code> in one go. This is more efficient for DragonRuby than doing it separately.</p>
<p><img src="./img/c03-fireball-sprite.jpg" alt="dragon sprite shooting 4 fireballs flying across the screen" /></p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's Next</a></h2>
<p>We're so close to having a game, so close! We just need something to spit fireballs at, right? In the next chapter, we'll display some floating targets that get destroyed when a fireball hits one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="target-practice"><a class="header" href="#target-practice">Target Practice</a></h1>
<p>For a dragon to gain accuracy in the fine art of breathing fire, they need to practice, right? Let's build out a feature where targets randomly spawn for our fireballs to collide with. We'll keep track of how many targets we've hit and use that as the main scoring component of our game.</p>
<h2 id="displaying-targets"><a class="header" href="#displaying-targets">Displaying Targets</a></h2>
<p>First, let's download the target sprite and put it in <code>mygame/sprites/target.png</code>:</p>
<p><img src="./code/chapter_04/01_display_targets/sprites/target.png" alt="target sprite" /></p>
<p>We'll keep track of the targets in an array, just like fireballs, so that we can more easily manage them throughout our game loop. Instead of initializing our targets as an empty array, let's start by displaying three of them:</p>
<pre><code class="language-ruby">  args.state.fireballs ||= []
  args.state.targets ||= [
    {
      x: 800,
      y: 120,
      w: 64,
      h: 64,
      path: 'sprites/target.png',
    },
    {
      x: 920,
      y: 600,
      w: 64,
      h: 64,
      path: 'sprites/target.png',
    },
    {
      x: 1020,
      y: 320,
      w: 64,
      h: 64,
      path: 'sprites/target.png',
    },
  ]
</code></pre>
<p>We need to render our target sprites too, so include those in the array we push into <code>args.outputs.sprites</code>:</p>
<pre><code class="language-ruby">  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs, args.state.targets]
</code></pre>
<p>Similar to how we represent the player and fireball sprites, the targets have an and x and y coordinate for position, a width and height, and an image file to represent the sprite. We create three items in our <code>args.state.targets</code> array, which then displays three different targets.</p>
<p><img src="./img/c04-display-targets.jpg" alt="dragon sprite with three targets rendered to the right" /></p>
<p>Try changing the <code>x</code> and <code>y</code> positions of our three targets. Weird. They don't change their position...</p>
<p>If you quit your game and relaunch <code>dragonruby</code>, they will though. Why is that?</p>
<p>Well, when DragonRuby loads our game code, if any value is set in <code>args.state</code> via <code>||=</code>, it won't reassign the new value because that value is already set. <code>args.state.targets</code> already has three targets in it, so when our code is reloaded, it doesn't know to discard our old targets.</p>
<p>Let's instruct DragonRuby to reset our state when the game runs by adding the special <code>$gtk.reset</code> after the <code>end</code> of <code>#tick</code>:</p>
<pre><code class="language-ruby">  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs, args.state.targets]
end

$gtk.reset
</code></pre>
<p>Now if we change the coordinates of our target, the game reloads our code and they change their position. This is a really awesome aspect of DragonRuby. We can easily adjust and modify the running game without having the rebuild it.</p>
<h2 id="our-first-method"><a class="header" href="#our-first-method">Our First Method</a></h2>
<p>There's something that's a bit of a bummer about our target array code. We duplicate a lot of values by having to specify the width, height, and image path. It'd be a bit annoying to have to change it in all those places even though we want them to be the same. Let's introduce our first method. While <code>#tick</code> is called automatically by DragonRuby, we can define our own methods that we call in our game to help organize our code. Methods are great for encapsulating a specific action. In our case, let's define a method that creates a target at a given x and y position.</p>
<pre><code class="language-ruby">def spawn_target x, y
  {
    x: x,
    y: y,
    w: 64,
    h: 64,
    path: 'sprites/target.png',
  }
end

def tick args
  args.state.player ||= {
    x: 120,
    y: 280,
    w: 100,
    h: 80,
    speed: 12,
    path: 'sprites/misc/dragon-0.png',
  }
  args.state.fireballs ||= []
  args.state.targets ||= [
    spawn_target(800, 120),
    spawn_target(920, 600),
    spawn_target(1020, 320),
  ]
</code></pre>
<p>Within <code>main.rb</code> we can define methods that are able to be called in <code>#tick</code>. Our new <code>spawn_target</code> method takes two parameters, the x and the y position, and then uses those parameters to return a hash representing the new target. In Ruby, method parameters are separated by commas. We pass parameters into methods that we want to have access to within that code. Because the width, height, and image don't change for a given target, those values stay the same and aren't passed in as parameters.</p>
<p>Then when we lazily assign <code>args.state.targets ||=</code>, we call the method three times, passing in the coordinates we want the target to spawn at.</p>
<p><code>#spawn_target</code> is a simple method, but we'll begin to see how we can expand upon the methods we write to make our code easy to understand while it gets more complex.</p>
<h2 id="collision-detection"><a class="header" href="#collision-detection">Collision Detection</a></h2>
<p>The fireballs our dragon spits just fly behind our targets and off the screen into infinity. Let's make it so that if a fireball hits a target, <em>something</em> happens. Eventually we'll want to play a sound, remove the target, and even play an animation. But humble beginnings, humble beginnings.</p>
<p>Collision detection is when one object overlaps with another object in our game. Because we're manufacturing the space the game exists in, there's no physics like we have in real life. We need to simulate that by checking to see if two objects are attempting to exist in the same point and react accordingly.</p>
<p>Our fireball sprite is a 32x32 square, so we want to check in every single game loop whether or not the points of the fireball's square overlapping with any of the points of the targets. If they are overlapping, then we do that <em>something</em>.</p>
<p>TODO: graphic of overlapping rects/squares explained</p>
<p>We could employ trigonometry to determine if a given point in one shape overlaps with another, but DragonRuby gives us a helpful method to handle this for us: <code>args.geometry.intersect_rect? rect_1, rect_2</code></p>
<p>It may seem odd that we're checking the intersection of two rectangles when our target is a circle and our fireball is almost a circle. Most 2D games use rectangles for their collision detection for the simplicity of it. Our images are already rectangles, and it's close enough for our purposes.</p>
<p>Here's the written out logic behind the collision detection we'll implement:</p>
<ul>
<li>In each <code>#tick</code>, keep our code for looping through and moving each fireball</li>
<li>After we move a fireball, loop through each target and check if the fireball is overlapping any of them</li>
<li>If they do overlap, output a message to the console</li>
</ul>
<pre><code class="language-ruby">  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        puts &quot;fireball hit target!&quot;
      end
    end
  end
</code></pre>
<p>Play the game and hit the some targets. Nothing visually happens (yet), but if you check the console (<kbd>~</kbd>), you'll see that <code>&quot;fireball hit target&quot;</code> was output multiple times.</p>
<p>With a loop and a method we've implemented collision detection. That wasn't too bad, was it?</p>
<h2 id="remove-targets-on-collision"><a class="header" href="#remove-targets-on-collision">Remove Targets On Collision</a></h2>
<p>But... It's not very helpful to output a message to the console when a target is hit. Let's instead remove the target so that it is no longer displayed. We'll need to delete the hit target from the array of targets so that it's no longer checked against.</p>
<p>Ruby makes that pretty easy. All you do is call the <code>#delete</code> method on an array and pass in the item you want to delete. If you have an array of numbers and call delete, it removes the item from the array:</p>
<pre><code class="language-ruby">nums = [3, 4, 5]
nums.delete(3)
nums # =&gt; [4, 5]
</code></pre>
<p>It works just like you think it would. So in our collision detection code where we call <code>puts</code>, we'll instead just delete the target <em>and</em> the fireball so they both get removed from their respective collections.</p>
<pre><code class="language-ruby">  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
      end
    end
  end
</code></pre>
<p>Since the target and fireball that collided are no longer being tracked in <code>args.state</code>, they don't get rendered on the screen and are, for all intents and purposes, gone!</p>
<p>This almost feels like a game. That's a great feeling. We're getting close to <em>fun</em>.</p>
<h2 id="spawn-new-targets"><a class="header" href="#spawn-new-targets">Spawn New Targets</a></h2>
<p>Shooting three targets and having them disappear doesn't make for much fun though. After the three targets are hit, it's just your dragon floating in the sky with not much else to do. We're back to chapter 3! Ugh, chapter 3 was so boring! I can't believe we ever even made anything that boring before. (But remember how cool it was when we got the fireballs working? That was cool! It's funny how games evolve and what it used to be seems so basic compared to where we're at now.)</p>
<p>Remember back in the day, way back when, like a few sections ago, when we introduced <code>#spawn_target</code>? It was helpful then, but now it's going to be even more helpful. We'll call it every time we destroy a target so that a new one spawns. We'll be able to play target practice forever!</p>
<p>But calling <code>spawn_target</code> with the same x and y over and over isn't a lot of fun. So let's make a few related changes where we'll do the following:</p>
<ol>
<li>Determine a random x and y position on the screen to spawn the target</li>
<li>Remove the x and y for our initial three targets so they get a random position</li>
<li>Spawn a new target in a random position when we hit one</li>
</ol>
<h3 id="spawn-at-a-random-location"><a class="header" href="#spawn-at-a-random-location">Spawn at a random location</a></h3>
<pre><code class="language-ruby">def spawn_target(args)
  size = 64
  {
    x: rand(args.grid.w * 0.4) + args.grid.w * 0.6,
    y: rand(args.grid.h - size * 2) + size,
    w: size,
    h: size,
    path: 'sprites/target.png',
  }
end
</code></pre>
<p><code>#spawn_target</code> looks a little different now. We no longer pass in the coordinates as arguments because we'll randomly generate the position. We instead pass in <code>args</code> from DragonRuby's <code>#tick</code> so that we can get the width and height of the screen to use to determine boundaries.</p>
<p>We create a <code>size</code> variable to store the width and height of the sprite to use in our formulas for spawning the target. We don't want to have to type 64 over and over because it loses its meaning and gets difficult to change.</p>
<p>Then we apply some math. Don't let math scare you away from programming! We'll keep it simple and the toolbox you need is relatively small. Plus, the math will help make our game even better. Games make math fun.</p>
<p><code>rand</code> is a method that we get from DragonRuby that's available everywhere. <code>rand</code> without any paramter generates a random number between 0 and 1. That's not really useful for us right now, so we can instead pass in a parameter that sets the upper boundary of the random number. <code>rand(100)</code> generates a random number between 0 up to 100 (not including 100).</p>
<p>So for the x position of the target, we generate a number random number that's up to two-fifths the size of width of the game and then we add three-fifths of the width to that number so that the targets spawn on the far right side of the screen. We don't want to spawn targets too close to the player, otherwise it'd be too easy.</p>
<p>For the y position, we generate a random y position based on the height of the game, but we subtract twice the size of the target sprite and then add one of its sizes back to the random number to give the spawn area a gutter. This prevents the target from spawning partially off the screen, which would make it impossible to hit.</p>
<h3 id="change-initial-three-targets"><a class="header" href="#change-initial-three-targets">Change initial three targets</a></h3>
<pre><code class="language-ruby">  args.state.targets ||= [
    spawn_target(args), spawn_target(args), spawn_target(args)
  ]
</code></pre>
<p>Instead of passing in the x and y position, we just call <code>#spawn_target</code> with DragonRuby's <code>args</code> so that we have access to the grid in our method. This gives us three randomly located targets.</p>
<h3 id="spawn-a-new-target-when-one-is-hit"><a class="header" href="#spawn-a-new-target-when-one-is-hit">Spawn a new target when one is hit</a></h3>
<pre><code class="language-ruby">  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
        args.state.targets &lt;&lt; spawn_target(args)
      end
    end
  end
</code></pre>
<p>We loop through the fireballs and move each one, just as before. And then we check to see if it intersects with any of the targets. If they do intersect, we delete both the fireball and the target.</p>
<p>The one new line is where we push a new target into <code>args.state.targets</code> from <code>#spawn_target</code>. That'll make a new target appear in a random location whenever we hit another.</p>
<p>Play the game a bit and see how feels. Is there anything that can be adjusted or improved? What if you adjust the formula for <code>#spawn_target</code>? How does that feel with targets spawning close or further away?</p>
<h2 id="score-tracking"><a class="header" href="#score-tracking">Score Tracking</a></h2>
<p>Let's keep track of how many targets we've destroyed before we call it a chapter.</p>
<p>The approach for this is pretty simple. We'll store a number in <code>args.state.score</code> and increase it each time we hit a target. Then we'll display that number on the screen as a label.</p>
<p>Near the top of <code>#tick</code>, lazily initialize <code>args.state.score</code> to <code>0</code>.</p>
<pre><code class="language-ruby">  args.state.fireballs ||= []
  args.state.targets ||= [
    spawn_target(args), spawn_target(args), spawn_target(args)
  ]
  args.state.score ||= 0

  if args.inputs.left
</code></pre>
<p>In our collision detection loop, when we delete the target and fireball, add <code>1</code> to our score:</p>
<pre><code class="language-ruby">        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
        args.state.score += 1
        args.state.targets &lt;&lt; spawn_target(args)
</code></pre>
<p>Finally, display our score as a label in the upper-left area of the screen:</p>
<pre><code class="language-ruby">  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs, args.state.targets]
  args.outputs.labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 40,
    text: &quot;Score: #{args.state.score}&quot;,
    size_enum: 4
  }
</code></pre>
<p>This approach to displaying a label is different than previous chapters. Instead of using an array to represent the properties of the label, we're now using a hash like we do for sprites (for similar reasons: it's easier to remember and more clear). Setting <code>x</code>, <code>y</code>, and <code>text</code> should be familiar by this point. But <code>size_enum</code> is new. It's a way to specify how large the text is. It takes whatever value we set and adds that much to the default text size. Increase it from <code>4</code> to <code>40</code> or <code>-3</code> and see what you lik ebest.</p>
<p><img src="./img/c04-score.jpg" alt="dragon spitting fireballs at three targets on the right side of the screen with the text 'Score: 34' displayed" /></p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>What a chapter! We displayed targets, handled collision detection, spawned our targets randomly, and added score tracking. We've come a long way in this chapter. And added a lot of core concepts that are found in most games. Review the code to make sure you understand it.</p>
<h2 id="extra-credit-1"><a class="header" href="#extra-credit-1">Extra Credit</a></h2>
<ul>
<li>There's a chance that our randomly generated targets can spawn on top of each other. How can you make it so that doesn't happen?</li>
<li>How could you change the collision detection to check if two circles overlap instead of rectangles?</li>
<li>We added gutters for the y position of our targets in <code>#spawn_target</code> for the top and bottom of the game screen, but how would you add a gutter for the x position so they don't spawn partially off the screen on the right side?</li>
</ul>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What's Next</a></h2>
<p>We'll take a brief side quest where we ask some big existential questions and clean up our fireballs that have flown off the screen before we turn this project we've been working on into a game that we can play and finish.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fireball-clean-up"><a class="header" href="#fireball-clean-up">Fireball Clean Up</a></h1>
<p>Time for a little side quest from the progress we've been making to clean up a small mess we've been making and learn a bit about performance optimizations.</p>
<p>As you've been shooting fireballs, have you wondered at all about what happens to all of those fireballs that fly off the right side of the screen?</p>
<p>Do you think they just... keep flying forever? Or do you think they just disappear from our game and our lives?</p>
<p>What if I told you that they don't disappear!</p>
<p>Whoa.</p>
<p>We could shoot thousands of fireballs that don't hit a target and our game is keeping track of them and updating their position over time. Let's demonstrate that.</p>
<h2 id="tracking-offscreen-fireballs"><a class="header" href="#tracking-offscreen-fireballs">Tracking Offscreen Fireballs</a></h2>
<p>DragonRuby gives us <code>args.outputs.debug</code>, which allows us to display shapes, labels, sprites, and more only when we're making our game. If we built it for release, the debug outputs wouldn't be displayed. Pretty nifty and really helpful for visually displaying information in each frame of our game.</p>
<p>Add these lines to the bottom of <code>#tick</code> after pushing our score text into <code>args.outputs.labels</code>:</p>
<pre><code class="language-ruby">  args.outputs.debug &lt;&lt; {
    x: 40,
    y: args.grid.h - 80,
    text: &quot;Fireballs: #{args.state.fireballs.length}&quot;,
  }.label!
  args.outputs.debug &lt;&lt; {
    x: 40,
    y: args.grid.h - 100,
    text: &quot;1st fireball x pos: #{args.state.fireballs.first&amp;.x}&quot;,
  }.label!
</code></pre>
<p>It displays two pieces of text in our game (but remember, only in debug mode). The total number of fireballs our game is keeping track of and the x position of the first fireball. The ampersand in front of <code>args.state.fireballs.first&amp;.x</code> says: if there's a first fireball, try to get its x property, otherwise don't throw an error. If we haven't hit the fire button, there's no first fireball in our array to get the <code>x</code> value of.</p>
<p><img src="./img/c05-debug-text.jpg" alt="debug mode text showing the dragon sprite with a score of 3, 36 fireballs, and an x position of the first fireball at 22,356" /></p>
<p>Spit a bunch of fireballs out and let your game run. You'll see the dozens of fireballs just keep going on and on forever, their x position steadily increasing.</p>
<h2 id="optimizing-our-game"><a class="header" href="#optimizing-our-game">Optimizing Our Game</a></h2>
<p>It's not very efficient to keep track of and update the position of fireballs that have no chance of ever hitting a target when they've gone off the screen. There could be thousands of fireballs, and sure, maybe our game still runs smoothly while we're testing, but there's a high chance that as our game gets more complex, there the sheer amount of data the game needs to process 60 times every second could get overwhelming and slow things down.</p>
<p>When making games, you need to be cognizant of performance. There are usually some straightforward fixes that can make a big difference.</p>
<p>In the case of our game, let's remove fireballs from our <code>args.state.fireballs</code> array when they fly off the screen. This will reduce the amount of processing load our game needs to handle.</p>
<pre><code class="language-ruby">  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    if fireball.x &gt; args.grid.w
      args.state.fireballs.delete(fireball)
      next
    end

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
        args.state.score += 1
        args.state.targets &lt;&lt; spawn_target(args)
      end
    end
  end
</code></pre>
<p>When looping through <code>args.state.fireballs</code>, we check to see if the x position of the fireball in the loop is greater than the width of the screen. If it is, then we delete the fireball, just like we do below on collision with a target. Then we call <code>next</code>, which tells the loop we're in to move on to the next fireball in the array and not the rest of the code in this iteration of the loop. Since we've removed the fireball from the game, we don't want to check it for collision.</p>
<p>Play your game and see that now as the fireballs fly off the screen, the total number of fireballs decreases. They no longer exist forever, flying off across the sky for all eternity, eating up our CPU cycles.</p>
<p>Feel free to remove the <code>args.outputs.debug</code> lines if you don't want to see them since they've served their purpose and are less useful now.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>There will be many opportunities when working on your games to optimize your code so that it performs better. This was just a taste of what that process can be like. As you get better and better at making games, you'll improve at making them more performant.</p>
<p>Don't obsesses over performance too much yet though. Focus on making your game fun to play.</p>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What's Next</a></h2>
<p>Now that we've cleaned up a small mess we've been making, let's get back to taking our game to the finish line by adding a timer to our game to see how many targets we can hit in 30 seconds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-attack"><a class="header" href="#time-attack">Time Attack</a></h1>
<p>We've <em>almost</em> got a game. But we need some way for the game to end. A lot of game loops end with the player's character dying, where they respawn or start over again. Other game loops end when the player reaches the end of a level.</p>
<p>For our simple game, let's add a 30 second timer that counts down. The objective of our game will be to see how many targets can the player hit in that time window. Let's call our game <strong>Target Practice</strong>. Every dragon needs some practice before they head out into battle, right?</p>
<p>Adding a timer to our game introduces a few new concepts we'll build out in this chapter:</p>
<ol>
<li>Keeping track of time and displaying it</li>
<li>Stopping our game when the timer runs out</li>
<li>Displaying a Game Over screen with the score</li>
<li>Allowing the player to restart the game and play again</li>
</ol>
<h2 id="getting-it-working"><a class="header" href="#getting-it-working">Getting It Working</a></h2>
<p>We'll start by introducing <code>args.state.timer</code> that will be used to keep track of how much time remains.</p>
<pre><code class="language-ruby">  args.state.score ||= 0
  args.state.timer ||= 30 * 60

  args.state.timer -= 1
</code></pre>
<p>We lazily set it to <code>30 * 60</code>. We want the game to last thirty seconds and our <code>#tick</code> method runs sixty times every second, so we multiple them together to get the total number of ticks our timer will run for. We'll then subtract one from <code>args.state.timer</code> every <code>#tick</code> so that it decreases as we play our game.</p>
<p>Right below decreasing our <code>args.state.timer</code> by one, we check to see if the timer is less than zero. If it is, that means game over.</p>
<pre><code class="language-ruby">  args.state.timer -= 1

  if args.state.timer &lt; 0
    labels = []
    labels &lt;&lt; {
      x: 40,
      y: args.grid.h - 40,
      text: &quot;Game Over!&quot;,
      size_enum: 10,
    }
    labels &lt;&lt; {
      x: 40,
      y: args.grid.h - 90,
      text: &quot;Score: #{args.state.score}&quot;,
      size_enum: 4,
    }
    labels &lt;&lt; {
      x: 40,
      y: args.grid.h - 132,
      text: &quot;Fire to restart&quot;,
      size_enum: 2,
    }
    args.outputs.labels &lt;&lt; labels

    if args.inputs.keyboard.key_down.z ||
        args.inputs.keyboard.key_down.j ||
        args.inputs.controller_one.key_down.a
      $gtk.reset
    end

    return
  end
</code></pre>
<p>If it is game over, then we let the player know, display their final score, and tell them how to play again (by pressing the fire button). We make an array of labels which we then push into <code>args.outputs.labels</code> to efficiently render them all.</p>
<p>If any of our fire keys are pressed, the game is reset with <code>$gtk.reset</code> and the player can play again.</p>
<p>The <code>return</code> line is <em>really</em> important. It says, return out of the <code>#tick</code> method so that none of the code below runs. We don't want to have the dragon be moveable or for targets to spawn when it's game over. So we eject early and only display the game over screen details.</p>
<p><img src="./img/c06-game-over.jpg" alt="game over screen showing a score of 11 with text saying 'Fire to restart'" /></p>
<p>Way at the bottom of <code>#tick</code>, let's display a label with the time remaining:</p>
<pre><code class="language-ruby">  labels = []
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 40,
    text: &quot;Score: #{args.state.score}&quot;,
    size_enum: 4,
  }
  labels &lt;&lt; {
    x: args.grid.w - 40,
    y: args.grid.h - 40,
    text: &quot;Time Left: #{(args.state.timer / 60).round}&quot;,
    size_enum: 2,
    alignment_enum: 2,
  }
  args.outputs.labels &lt;&lt; labels
</code></pre>
<p>We use the same pattern of creating a <code>labels</code> array, pushing in the player's score and the time remaining. In order to get the time remaining, we divide it by 60 and round. We do the opposite of what we did when we set the total time in ticks.</p>
<p>The <code>alignment_enum</code> let's us specify that we want the text to be right aligned instead of the default left alignment. This let's us nicely position our timer in the upper right corner of the game.</p>
<p><img src="./img/c06-timer.jpg" alt="gameplay with Time Left reading 10 seconds" /></p>
<p>We've got ourselves a game that we can start, finish, and replay. Isn't that pretty awesome?</p>
<h2 id="restart-grace-period"><a class="header" href="#restart-grace-period">Restart Grace Period</a></h2>
<p>If you happen to press the fire button right when the timer runs out, you may restart your game without even seeing the game over screen. Let's add a little grace period between when the game is over and when we start accepting input to restart. 30 frames should be plenty and it won't even be noticeable to the player.</p>
<pre><code class="language-ruby">    if args.state.timer &lt; -30 &amp;&amp;
        (args.inputs.keyboard.key_down.z ||
        args.inputs.keyboard.key_down.j ||
        args.inputs.controller_one.key_down.a)
      $gtk.reset
    end
</code></pre>
<p>Beause we keep subtracting from <code>args.state.timer</code>, we can check to see if the current value is less than -30. If it is, then we'll accept input to restart the game.</p>
<p><code>&amp;&amp;</code> (double ampersand, often read as &quot;and-and&quot;) means that both sides of the expression must be true for the code within the conditional to happen. In our new restart check, we combine AND and OR by saying: if the game timer is less than -30 AND any of our fire keys are down, then we reset the game. When you group together expressions in parentheses, <code>(monday? || tuesday?)</code>, it evaluates them as one express against the other checks. We care about the timer being below a certain amount AND any of the inputs beingpressed.</p>
<p>Combining logic in this way for flow control is very common when making games. <code>&amp;&amp;</code> and <code>||</code> are pretty common operators in most programming languages.</p>
<h2 id="refactor"><a class="header" href="#refactor">Refactor</a></h2>
<p>Our main <code>#tick</code> method is getting a bit long in the tooth, being over 100 lines long. We've also duplicated two things: frames per second with the <code>60</code> value and checking for fire input. This is a good opportunity to refactor our code once again to make it easier to work with. Let's break up <code>#tick</code> into a series of smaller methods that we call from within it. Encapsulating our logic into smaller pieces makes it easier to work on those smaller pieces without concerning ourselves with the rest of the code.</p>
<p>How small should you make your methods? That's up to you. Use your best judgement and do what feels right. Code can change and grow quite organically. Once something feels too big or complex or is duplicated, improve it. Don't over-engineer your game right from the start, otherwise you'll be off in the weeds and not actually making your game fun. On the other hand, if you just neglect your code, you'll make it more difficult to change, thus slowing down the development process. There's a fine line between over-engineering and creating a mess.</p>
<p>Here's the entire game broken down into some smaller methods to make it easier to work with moving forward:</p>
<pre><code class="language-ruby">FPS = 60

def spawn_target(args)
  size = 64
  {
    x: rand(args.grid.w * 0.4) + args.grid.w * 0.6,
    y: rand(args.grid.h - size * 2) + size,
    w: size,
    h: size,
    path: 'sprites/target.png',
  }
end

def fire_input?(args)
  args.inputs.keyboard.key_down.z ||
    args.inputs.keyboard.key_down.j ||
    args.inputs.controller_one.key_down.a
end

def handle_player_movement(args)
  if args.inputs.left
    args.state.player.x -= args.state.player.speed
  elsif args.inputs.right
    args.state.player.x += args.state.player.speed
  end

  if args.inputs.up
    args.state.player.y += args.state.player.speed
  elsif args.inputs.down
    args.state.player.y -= args.state.player.speed
  end

  if args.state.player.x +  args.state.player.w &gt; args.grid.w
    args.state.player.x = args.grid.w - args.state.player.w
  end

  if args.state.player.x &lt; 0
    args.state.player.x = 0
  end

  if args.state.player.y + args.state.player.h &gt; args.grid.h
    args.state.player.y = args.grid.h - args.state.player.h
  end

  if args.state.player.y &lt; 0
    args.state.player.y = 0
  end
end

def game_over_tick(args)
  labels = []
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 40,
    text: &quot;Game Over!&quot;,
    size_enum: 10,
  }
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 90,
    text: &quot;Score: #{args.state.score}&quot;,
    size_enum: 4,
  }
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 132,
    text: &quot;Fire to restart&quot;,
    size_enum: 2,
  }
  args.outputs.labels &lt;&lt; labels

  if args.state.timer &lt; -30 &amp;&amp; fire_input?(args)
    $gtk.reset
  end
end

def tick args
  args.state.player ||= {
    x: 120,
    y: 280,
    w: 100,
    h: 80,
    speed: 12,
    path: 'sprites/misc/dragon-0.png',
  }
  args.state.fireballs ||= []
  args.state.targets ||= [
    spawn_target(args), spawn_target(args), spawn_target(args)
  ]
  args.state.score ||= 0
  args.state.timer ||= 30 * FPS

  args.state.timer -= 1

  if args.state.timer &lt; 0
    game_over_tick(args)
    return
  end

  handle_player_movement(args)

  if fire_input?(args)
    args.state.fireballs &lt;&lt; {
      x: args.state.player.x + args.state.player.w - 12,
      y: args.state.player.y + 10,
      w: 32,
      h: 32,
      path: 'sprites/fireball.png',
    }
  end

  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    if fireball.x &gt; args.grid.w
      args.state.fireballs.delete(fireball)
      next
    end

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
        args.state.score += 1
        args.state.targets &lt;&lt; spawn_target(args)
      end
    end
  end

  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs, args.state.targets]

  labels = []
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 40,
    text: &quot;Score: #{args.state.score}&quot;,
    size_enum: 4,
  }
  labels &lt;&lt; {
    x: args.grid.w - 40,
    y: args.grid.h - 40,
    text: &quot;Time Left: #{(args.state.timer / FPS).round}&quot;,
    size_enum: 2,
    alignment_enum: 2,
  }
  args.outputs.labels &lt;&lt; labels
end

$gtk.reset
</code></pre>
<p>Because so much has changed and shifted around, I'll just walkthrough the main changes:</p>
<ul>
<li><code>FPS</code> is a constant, which is a special value in Ruby that doesn't change. We assign it to <code>60</code> because our game runs at sixty (f)rames (p)er (s)econd. That value won't change, but it's more helpful in our math code to see <code>FPS</code> rather than <code>60</code> because we now know what that value represents.</li>
<li><code>#fire_input?</code> checks to see if any of our keys are down for firing a fireball. By using our method, we can easily adjust it without having to change it for both restarting the game and the dragon spitting the fireball.</li>
<li><code>#handle_player_movement</code> does just what it describes. That code has a lot of checks but we haven't changed much, so let's put it in a method to get it out of the way.</li>
<li><code>#game_over_tick</code> is our own special method for when it's game over that gets called from our main <code>#tick</code>. It makes it easier to refer to and change what happens when our game is over.</li>
</ul>
<p>I hear you over there screaming, &quot;You expect me to rewrite the entire game line-by-line?!?! I quit!&quot; It's okay to copy and paste what's provided above into your game. If you've made some adjustments, make them again. This refactored code is going to be the foundation for the rest of the book.</p>
<h2 id="whats-next-5"><a class="header" href="#whats-next-5">What's Next</a></h2>
<p>We've got a working game, but it's a bit... boring. Let's polish our game up by adding high-score tracking, sounds, animations, and more. We've got a working core of a fun game, and now it's time to make it a great experience.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-score"><a class="header" href="#high-score">High-Score</a></h1>
<p>Saving and loading game data is a key piece of functionality when it comes to making games. We may want to keep track of all sorts of important data across play sessions. For <em>Target Practice</em>, let's keep it simple and keep track of the high-score each time a new one is set.</p>
<h2 id="load--save-data"><a class="header" href="#load--save-data">Load &amp; Save Data</a></h2>
<p>When the game is over, let's display whether or not a new high-score was achieved. If it is higher than the previous, we'll save that new high-score. Otherwise, we'll display the high-score and encourage the player to try to beat it.</p>
<p>This will require two parts to working with save data:</p>
<ul>
<li>Saving the score when a new high-score is achieved</li>
<li>Loading the previous high-score to compare the player's score to</li>
</ul>
<p>DragonRuby GTK gives us two handy methods to do so:</p>
<ul>
<li><code>args.gtk.write_file(&quot;high-score.txt&quot;)</code></li>
<li><code>args.gtk.read_file(&quot;high-score.txt&quot;)</code></li>
</ul>
<p>Save data, especially for our game, can be as simple as a text file on the computer. While this may allow for save tampering, that's not something we're too worried about for our game. The foundations of writing our data to a file and loading it apply no matter how complex our game data persistent needs get.</p>
<p>We'll be working exclusively in <code>#game_over_tick</code>:</p>
<pre><code class="language-ruby">HIGH_SCORE_FILE = &quot;high-score.txt&quot;
def game_over_tick(args)
  args.state.high_score ||= args.gtk.read_file(HIGH_SCORE_FILE).to_i

  if !args.state.saved_high_score &amp;&amp; args.state.score &gt; args.state.high_score
    args.gtk.write_file(HIGH_SCORE_FILE, args.state.score.to_s)
    args.state.saved_high_score = true
  end
</code></pre>
<p>We read the value from the <code>HIGH_SCORE_FILE</code>, which is <code>high-score.txt</code>. If the file doesn't exist, it'll be <code>0</code> because we call <code>#to_i</code> on the file reading process.</p>
<p>Then, if we haven't saved the high-score yet and the player's score is greater than the high-score, we save it in the file and set a value in <code>args.state.saved_high_score</code> so that we don't save it every single time <code>#game_over_tick</code> gets called each frame of the game.</p>
<pre><code class="language-ruby">  if args.state.score &gt; args.state.high_score
    labels &lt;&lt; {
      x: 260,
      y: args.grid.h - 90,
      text: &quot;New high-score!&quot;,
      size_enum: 3,
    }
  else
    labels &lt;&lt; {
      x: 260,
      y: args.grid.h - 90,
      text: &quot;Score to beat: #{args.state.high_score}&quot;,
      size_enum: 3,
    }
  end
</code></pre>
<p>When we're constructing our <code>labels</code> to render, we add a condition that checks if we've got a new high-score. If we do, then we let the player know. Otherwise we display the current high-score for them to chase after.</p>
<p><img src="./img/c07-low-score.jpg" alt="game over screen showing a score of 1 and a high-score of 4" /></p>
<p><img src="./img/c07-high-score.jpg" alt="game over screen showing a new high-score of 30" /></p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>We load and save data relating to how our player has done. While saving one value is likely to be a bit too trivial for most games, the core concepts are pretty similar. You'll write your data to a file, you read that file, and then you do whatever you need to with it.</p>
<h2 id="extra-credit-2"><a class="header" href="#extra-credit-2">Extra Credit</a></h2>
<ul>
<li>How would you save the date and time the high-score was achieved at?</li>
<li>Displaying one high-score is neat. But what if it showed the last 5 scores in addition to the highest score?</li>
</ul>
<h2 id="whats-next-6"><a class="header" href="#whats-next-6">What's Next</a></h2>
<p>Let's add some music and sound effects to our game. Even just a simple track with a couple sound effects will make a <em>significant</em> difference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound"><a class="header" href="#sound">Sound</a></h1>
<p>One of the quickest ways to make any game you're building go from feeling flat to having some oomph is to add sound. Whenever any button is pressed, play a sound effect. Play music in the background. If your game has multiple moods, change the music based on the level or part of your game.</p>
<p>For <em>Target Practice</em>, we'll have three unique sound effects:</p>
<ol>
<li>When the fireball is spit by the dragon</li>
<li>When the fireball hits a target</li>
<li>When the game ends</li>
</ol>
<p>We'll also add in a music track that plays in the background.</p>
<p>Download the following files and put them in the <code>mygame/sounds/</code> folder:</p>
<ul>
<li><a href="./code/chapter_08/01_sound/sounds/fireball.wav">fireball.wav</a></li>
<li><a href="./code/chapter_08/01_sound/sounds/target.wav">target.wav</a></li>
<li><a href="./code/chapter_08/01_sound/sounds/game-over.wav">game-over.wav</a></li>
<li><a href="./code/chapter_08/01_sound/sounds/flight.ogg">flight.ogg</a></li>
</ul>
<p>A note on audio file formats: in DragonRuby, sound effects are generally WAV (<code>.wav</code>) files. WAV files are uncompressed, meaning they can be quite large in size, but are high-quality. Because sound effects are so short, the file size is less of a concern. Music files are OGG (<code>.ogg</code>), an open-source format for audio that works across all of the platforms you game can run on. OGG files are compressed, thus smaller in size than WAV files, making them good for music tracks.</p>
<h2 id="playing-sounds-in-dragonruby-game-toolkit"><a class="header" href="#playing-sounds-in-dragonruby-game-toolkit">Playing Sounds in DragonRuby Game Toolkit</a></h2>
<p>DragonRuby GTK gives us a really simple way to play a sound in our game. You push a string of the path of the sound into <code>args.outputs.sounds</code> and it plays once:</p>
<pre><code class="language-ruby">args.outputs.sounds &lt;&lt; &quot;sounds/fireball.wav&quot;
</code></pre>
<p>Easy enough!</p>
<p>Playing music is a little more complex, but still pretty simple. You set a value on the <code>args.audio</code> hash that lets you manage the audio track across the game loop. You can check the current progress, whether or not it's paused, and more. That looks like:</p>
<pre><code class="language-ruby">if args.state.tick_count == 1
  args.audio[:music] = { input: &quot;sounds/flight.ogg&quot;, looping: true }
end
</code></pre>
<p>That says when we're on the first tick, play the <code>flight.ogg</code> music track on repeat. We only want to run that code once because we don't want to start it over and over each <code>#tick</code>. The <code>:music</code> key can be any value we want. If you have multiple music tracks in your game, you can use a different key to manage the various tracks.</p>
<h2 id="add-music--sound-effects-to-our-game"><a class="header" href="#add-music--sound-effects-to-our-game">Add Music &amp; Sound Effects To Our Game</a></h2>
<p>Let's add the sound effects and music track to the game.</p>
<p>Let's kick things off by starting the music track on the first tick at the top of <code>#tick</code>:</p>
<pre><code class="language-ruby">def tick args
  if args.state.tick_count == 1
    args.audio[:music] = { input: &quot;sounds/flight.ogg&quot;, looping: true }
  end
</code></pre>
<p>If you've got the files in the right place and start your game, you'll hear the music play.</p>
<p>Above our check for whether or not the game is over, when the timer is 0, let's play <code>game-over.ogg</code> and pause the music:</p>
<pre><code class="language-ruby">  args.state.timer -= 1

  if args.state.timer == 0
    args.audio[:music].paused = true
    args.outputs.sounds &lt;&lt; &quot;sounds/game-over.wav&quot;
  end

  if args.state.timer &lt; 0
    game_over_tick(args)
    return
  end
</code></pre>
<p>Right above when we add a new fireball to <code>args.state.fireballs</code>, play <code>fireball.wav</code>:</p>
<pre><code class="language-ruby">  if fire_input?(args)
    args.outputs.sounds &lt;&lt; &quot;sounds/fireball.wav&quot;
    args.state.fireballs &lt;&lt; {
      x: args.state.player.x + args.state.player.w - 12,
      y: args.state.player.y + 10,
      w: 32,
      h: 32,
      path: 'sprites/fireball.png',
    }
  end
</code></pre>
<p>And, finally, when a fireball hits a target, let's play <code>target.wav</code>:</p>
<pre><code class="language-ruby">    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        args.outputs.sounds &lt;&lt; &quot;sounds/target.wav&quot;
        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
        args.state.score += 1
        args.state.targets &lt;&lt; spawn_target(args)
      end
    end
  end
</code></pre>
<p>Now we've got music and sound effects in our game. Isn't it wild how the game feels more fun and polished?</p>
<h2 id="make-your-own-music--sound-effects"><a class="header" href="#make-your-own-music--sound-effects">Make Your Own Music &amp; Sound Effects</a></h2>
<p>I use <a href="https://sfxr.me/">jsfxr</a> to create sound effects for games. It's simple and free with a lot of settings to tweak. You can quickly download a WAV file that you can drop into your game. Try making your own sound effects and replacing the ones I've provided. You often won't know if a sound effect sounds <em>right</em> until you drop it in your game. So experiment and see what works best.</p>
<p>As for making your own music, there are lots of options out there. I use <a href="https://1bitdragon.com/">1BitDragon</a>, a limited (in a good way) tool for making music. <a href="https://lmms.io/">LMMS</a> is a freel, well-loved tool. Garageband on MacOS would get you pretty far too!</p>
<p>There are many ways to convert the sounds you make to various formats, from command-line tools like ffmpeg to desktop apps. <a href="https://convertio.co/">Convertio</a> is a free online service, among many, that you can use as well.</p>
<p>Making music and sound effects for games is a huge topic that's beyond the scope of this book, but hopefully these tools can help you get started.</p>
<p>If you do change the sounds in your game, you'll need to restart it to get DragonRuby GTK to refresh them.</p>
<h2 id="extra-credit-3"><a class="header" href="#extra-credit-3">Extra Credit</a></h2>
<ul>
<li>Replace the provided sound effects with ones you made</li>
<li>Make your own music and drop it in</li>
<li>It can be a little bit annoying to hear the music over and over while you're making your game, so how would you make it so you can mute the music while working on it? <a href="https://www.dragonriders.community/recipes/music">This resource can help you out.</a></li>
</ul>
<h2 id="whats-next-7"><a class="header" href="#whats-next-7">What's Next</a></h2>
<p>In the next chapter we'll continue to polish our game to prepare it for release by making the background blue and displaying clouds that float by.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background"><a class="header" href="#background">Background</a></h1>
<p>We're eight chapters in and haven't even touched upon a simple and useful piece of functionality that DragonRuby GTK gives us: drawing rectangles! Rectangles are great for backgrounds, text boxes and more. Layer some sprites on top, and you can get pretty fancy.</p>
<h2 id="blue-sky"><a class="header" href="#blue-sky">Blue Sky</a></h2>
<p>Up until now, our dragon has been flying around in a gray sky. Let's make the sky blue to start.</p>
<p>DragonRuby provides <code>args.outputs.solids</code> to easy display filled rectangles.</p>
<p>At the top of <code>#tick</code>, below where we start the music, create a solid rectangle that's the size of the screen and placed at 0, 0:</p>
<pre><code class="language-ruby">def tick args
  if args.state.tick_count == 1
    args.audio[:music] = { input: &quot;sounds/flight.ogg&quot;, looping: true }
  end

  args.outputs.solids &lt;&lt; {
    x: 0,
    y: 0,
    w: args.grid.w,
    h: args.grid.h,
    r: 92,
    g: 120,
    b: 230,
  }
</code></pre>
<p>We're familiar with a lot of the shape hash keys for the position and size, but <code>r</code>, <code>g</code>, and <code>b</code> are new. They specify the values for the red, green, and blue color values for the rectangle we're drawing. Their values can be set to anything between 0 and 255, inclusive. Adjust the values to see a different color displayed. The higher the value for a given color, the more it'll be part of the mix. So our color has a blue of 230, meaning blue comes through more than the others. You can also specify <code>a</code>, the alpha value, between 0 and 100, inclusive, to get transparency in our shape.</p>
<p>Now we've got our dragon flying over a blue sky. That looks quite a bit better.</p>
<p><img src="./img/c09-blue-sky.jpg" alt="game with dragon and three targets and blue background" /></p>
<h2 id="extra-credit-4"><a class="header" href="#extra-credit-4">Extra Credit</a></h2>
<ul>
<li>Make (or find) some cloud sprites and render those in the sky. Put them in the <code>args.outputs.sprites</code> <em>before</em> the other sprites to have them render behind.</li>
<li>Move the clouds, randomly placing at a different position and with a different size when they go off the screen.</li>
<li>Draw some more rectangles under the score and timer to make them easier to read.</li>
</ul>
<h2 id="whats-next-8"><a class="header" href="#whats-next-8">What's Next</a></h2>
<p>We've got one more piece of polish to implement‚Äîanimation! Let's make our dragon flap their wings because they're flying in the sky.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation"><a class="header" href="#animation">Animation</a></h1>
<p>While the polish we've implemented in our game is making it feel a lot better to play, it feels a bit lifeless. There's a key piece missing that we haven't covered yet. It's animation! Whether it's Sonic tapping his foot when he hasn't moved in a while or his feet moving as he runs, animating our sprites gives our game personality. It makes the game feel alive.</p>
<p>Have you ever made a flip animation in the bottom corner of a notebook? You draw each frame and then flip through the pages quickly to see it animate. That concept of drawing the frames and each frame subtly changing what's drawn to convey motion is core to 2D animation, whether it's a game, an animated GIF, or a classic Disney film.</p>
<p>In this chapter we'll make our dragon flap its wings because it's flying through the air.</p>
<h2 id="animating-our-dragon"><a class="header" href="#animating-our-dragon">Animating Our Dragon</a></h2>
<p>In <code>mygame/sprites/misc/</code> there are more dragon images than just <code>dragon-0.png</code>. There are 5 additional frames of the dragon flapping their wings. Perfect! That's just what we need.</p>
<p>The core of how this will work is that each dragon frame will be displayed for some period of time and then we'll switch to the next frame after that time has passed.</p>
<pre><code class="language-ruby">  args.state.player ||= {
    x: 120,
    y: 280,
    w: 100,
    h: 80,
    speed: 12,
  }

  player_sprite_index = 0.frame_index(count: 6, hold_for: 8, repeat: true)
  args.state.player.path = &quot;sprites/misc/dragon-#{player_sprite_index}.png&quot;
</code></pre>
<p>Where we lazily set <code>args.state.player</code>, we no longer specify the <code>path</code> to the sprite. We'll set that as part of animating the player right below.</p>
<p><code>#frame_index</code> is a method DragonRuby GTK gives us on integers to keep track of what frame to use when animating. <code>0</code> is when we want to start the animation, which we want to start at the beginning. We have 6 frames total, and we want to display each of them for 8 ticks, repeating forever! Change the <code>hold_for</code> value and see how it affects the animation speed and feel of the game. Pick a rate that feels good for you or just stick with 8.</p>
<p>Then we take the <code>player_sprite_index</code> and use that when specifying the <code>path</code> of our player sprite by interpolating it into the path to our sprite. Our dragon sprites are named <code>dragon-0.png</code>, <code>dragon-1.png</code>, and so on. So we take what <code>#frame_index</code> gives us and inject it into the path to the image to make that value dynamic.</p>
<p>In Ruby, when you have a string that uses double quotes, <code>&quot;hi there&quot;</code>, you can inject Ruby code inside of it using <code>#{}</code>. This is really useful and is known as string interpolation. For example: <code>&quot;2 + 2 = #{2 + 2}&quot;</code>, that evaluates the mathematical expression and converts the answer (<code>4</code>) to a string and returns <code>&quot;2 + 2 = 4&quot;</code>.</p>
<h2 id="a-note-on-spritesheets"><a class="header" href="#a-note-on-spritesheets">A Note on Spritesheets</a></h2>
<p>If you've done any game development before, you may be familiar with spritesheets, where each frame of an animation is contained within one image file. When using a spritesheet for animation, instead of changing which image file path is used for the sprite to render, you change which piece of the large spritesheet you render. <a href="https://bit.ly/drgtk-spritesheet">The DragonRuby GTK docs have a detailed example on how to do this.</a></p>
<h2 id="extra-credit-5"><a class="header" href="#extra-credit-5">Extra Credit</a></h2>
<ul>
<li>How would you increase the animation speed when the dragon is moving to simulate faster flapping of their wings?</li>
<li>Animate the fireball with another frame of animation to make it feel alive</li>
<li>Animate the targets in some way</li>
</ul>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>When making a game, it's likely that anything that moves will animate, even if it's just a little. It's a valuable concept to understand and implement on your own. Compare the game now to when we started‚Äîit's come quite a long way from an immovable sprite with some text!</p>
<h2 id="whats-next-9"><a class="header" href="#whats-next-9">What's Next</a></h2>
<p>We're nearly finished with our game! All that's left is to add a title screen and then publish the game online.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scenes"><a class="header" href="#scenes">Scenes</a></h1>
<p>When making a game, there are all sorts of scenes that exist, from the main menu to the actual gameplay to the pause menu. Often these scenes have different interactions than the main game. Instead of moving your character around the world you instead move a cursor up and down menu options. In this chapter we'll refactor our main gameplay and game over state to be a bit easier to manage and then introduce a title scene that's used to start the game.</p>
<p>The concept of a &quot;scene&quot; isn't specific to DragonRuby Game Toolkit or any given game engine. It's just a generic concept that we're introducing to make our game code easier to work with. In GameMaker they're called &quot;rooms&quot; and in HaxeFlixel they're called &quot;states.&quot; For our purposes, we'll move forward with scenes because they don't conflict with other terms in DragonRuby GTK, and much like a movie scene, it's clear when one ends and when one begins.</p>
<h2 id="refactor-1"><a class="header" href="#refactor-1">Refactor</a></h2>
<p>When we introduced the game over scene, we actually introduced our second scene. Kinda neat! But it wasn't the time to think about them in terms of scenes and reckon with how we add more.</p>
<p>So we've got two scenes right now: gameplay (where we shoot at targets) and game over (where we display the score and allow the player to restart). Let's refactor the code to put our scenes in different methods and allow the game to switch between them given certain conditions being met.</p>
<p>Containing our scenes in methods will make it much easier to change one scene without impacting the others. It sets clear boundaries and will make our code easier to maintain.</p>
<p>We've already got <code>#game_over_tick</code>, so we can make use of that to contain the game over behavior.</p>
<p>Let's introduce a <code>#gameplay_tick</code> method that will contain the logic for our gameplay. And then we'll use <code>args.state.scene</code> to keep track of the current scene. Then if we change that value, it'll change what scene our game uses.</p>
<p>Not much of the code changes, but we do shuffle things around a bit. None of the methods above <code>#game_over_tick</code> change, so they're excluded:</p>
<pre><code class="language-ruby">HIGH_SCORE_FILE = &quot;high-score.txt&quot;
def game_over_tick(args)
  args.state.high_score ||= args.gtk.read_file(HIGH_SCORE_FILE).to_i

  args.state.timer -= 1

  if !args.state.saved_high_score &amp;&amp; args.state.score &gt; args.state.high_score
    args.gtk.write_file(HIGH_SCORE_FILE, args.state.score.to_s)
    args.state.saved_high_score = true
  end

  labels = []
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 40,
    text: &quot;Game Over!&quot;,
    size_enum: 10,
  }
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 90,
    text: &quot;Score: #{args.state.score}&quot;,
    size_enum: 4,
  }

  if args.state.score &gt; args.state.high_score
    labels &lt;&lt; {
      x: 260,
      y: args.grid.h - 90,
      text: &quot;New high-score!&quot;,
      size_enum: 3,
    }
  else
    labels &lt;&lt; {
      x: 260,
      y: args.grid.h - 90,
      text: &quot;Score to beat: #{args.state.high_score}&quot;,
      size_enum: 3,
    }
  end

  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 132,
    text: &quot;Fire to restart&quot;,
    size_enum: 2,
  }
  args.outputs.labels &lt;&lt; labels

  if args.state.timer &lt; -30 &amp;&amp; fire_input?(args)
    $gtk.reset
  end
end

def gameplay_tick(args)
  args.outputs.solids &lt;&lt; {
    x: 0,
    y: 0,
    w: args.grid.w,
    h: args.grid.h,
    r: 92,
    g: 120,
    b: 230,
  }

  args.state.player ||= {
    x: 120,
    y: 280,
    w: 100,
    h: 80,
    speed: 12,
  }

  player_sprite_index = 0.frame_index(count: 6, hold_for: 8, repeat: true)
  args.state.player.path = &quot;sprites/misc/dragon-#{player_sprite_index}.png&quot;

  args.state.fireballs ||= []
  args.state.targets ||= [
    spawn_target(args), spawn_target(args), spawn_target(args)
  ]
  args.state.score ||= 0
  args.state.timer ||= 30 * FPS

  args.state.timer -= 1

  if args.state.timer == 0
    args.audio[:music].paused = true
    args.outputs.sounds &lt;&lt; &quot;sounds/game-over.wav&quot;
    args.state.scene = &quot;game_over&quot;
    return
  end

  handle_player_movement(args)

  if fire_input?(args)
    args.outputs.sounds &lt;&lt; &quot;sounds/fireball.wav&quot;
    args.state.fireballs &lt;&lt; {
      x: args.state.player.x + args.state.player.w - 12,
      y: args.state.player.y + 10,
      w: 32,
      h: 32,
      path: 'sprites/fireball.png',
    }
  end

  args.state.fireballs.each do |fireball|
    fireball.x += args.state.player.speed + 2

    if fireball.x &gt; args.grid.w
      args.state.fireballs.delete(fireball)
      next
    end

    args.state.targets.each do |target|
      if args.geometry.intersect_rect?(target, fireball)
        args.outputs.sounds &lt;&lt; &quot;sounds/target.wav&quot;
        args.state.targets.delete(target)
        args.state.fireballs.delete(fireball)
        args.state.score += 1
        args.state.targets &lt;&lt; spawn_target(args)
      end
    end
  end

  args.outputs.sprites &lt;&lt; [args.state.player, args.state.fireballs, args.state.targets]

  labels = []
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 40,
    text: &quot;Score: #{args.state.score}&quot;,
    size_enum: 4,
  }
  labels &lt;&lt; {
    x: args.grid.w - 40,
    y: args.grid.h - 40,
    text: &quot;Time Left: #{(args.state.timer / FPS).round}&quot;,
    size_enum: 2,
    alignment_enum: 2,
  }
  args.outputs.labels &lt;&lt; labels
end

def tick args
  if args.state.tick_count == 1
    args.audio[:music] = { input: &quot;sounds/flight.ogg&quot;, looping: true }
  end

  args.state.scene ||= &quot;gameplay&quot;

  send(&quot;#{args.state.scene}_tick&quot;, args)
end
</code></pre>
<p><code>#game_over_tick</code> is the same except for the addition of:</p>
<pre><code class="language-ruby">args.state.timer -= 1
</code></pre>
<p>We need to continue to subtract from the timer in each tick since we rely upon it for when we accept input to restart the game.</p>
<p>We introduce <code>#gameplay_tick</code> which contains all of our logic for when we're actually playing the game. We set the background to the blue solid rectangle and initialize our player and animate the sprite. That's all the same.</p>
<p>But when the timer is <code>0</code>, after we pause the music and play the game over sound, we set <code>args.state.scene</code> to <code>&quot;game_over&quot;</code> and return early. This effectively changes the scene.</p>
<p>We continue to handle input and display the gameplay sprites and labels in <code>#gameplay_tick</code>.</p>
<p>Then, finally, <code>#tick</code> has been drastically simplified. It no longer needs to be responsible for so much. It can instead just handle three things:</p>
<ol>
<li>starting the music for the game</li>
<li>Lazily initializing the scene to start with (in our case, <code>&quot;gameplay&quot;</code>)</li>
<li>Calling the proper scene tick method and passing in <code>args</code></li>
</ol>
<p>The third item there is the new part of this chapter. <code>#send</code> is a method in Ruby that allows a method to be called by passing in the name of the method as a parameter. This is really powerful! We use string interpolation to take the value set in <code>args.state.scene</code> and append it with <code>_tick</code>. Our game then calls that method and passes in <code>args</code> as the first parameter to the called method. So if <code>args.state.scene</code> is set to <code>&quot;gameplay&quot;</code>, the <code>#gameplay_tick</code> method gets called. If it's set to <code>&quot;game_over&quot;</code>, then <code>#game_over_tick</code> gets called. If it's set to <code>&quot;credits&quot;</code>, then <code>#credits_tick</code> would get called.</p>
<p>The various scene tick methods <em>need</em> to exist in order for changing <code>args.state.scene</code> to work. But that's quite simple to do, we just introduce a new method and set <code>args.state.scene</code> to change between scenes.</p>
<h2 id="title-scene"><a class="header" href="#title-scene">Title Scene</a></h2>
<p>When player's launch our game, they get dropped right into the gameplay. This can be a bit jarring, so let's introduce a new scene that displays the title of the game, controls, and let's them press a button to start.</p>
<p>In our game code, let's introduce <code>#title_tick</code> that takes <code>args</code> as its only parameter, just like our other <code>*_tick</code> methods for our scenes. In <code>#title_tick</code>, we'll render some labels and look for input to start our game. If the fireball input is pressed, we'll play a sound effect, change the scene, and return early so we can move on to the next scene.</p>
<pre><code class="language-ruby">def title_tick args
  if fire_input?(args)
    args.outputs.sounds &lt;&lt; &quot;sounds/game-over.wav&quot;
    args.state.scene = &quot;gameplay&quot;
    return
  end

  labels = []
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 40,
    text: &quot;Target Practice&quot;,
    size_enum: 6,
  }
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 88,
    text: &quot;Hit the targets!&quot;,
  }
  labels &lt;&lt; {
    x: 40,
    y: args.grid.h - 120,
    text: &quot;by YOU&quot;,
  }
  labels &lt;&lt; {
    x: 40,
    y: 120,
    text: &quot;Arrows or WASD to move | Z or J to fire | gamepad works too&quot;,
  }
  labels &lt;&lt; {
    x: 40,
    y: 80,
    text: &quot;Fire to start&quot;,
    size_enum: 2,
  }
  args.outputs.labels &lt;&lt; labels
end
</code></pre>
<p>Replace <code>YOU</code> with your name since you made it. It's important to take credit for your work.</p>
<p>Then in <code>#tick</code> lazily initialize <code>args.state.scene</code> to now be <code>&quot;title&quot;</code>:</p>
<pre><code class="language-ruby">def tick args
  if args.state.tick_count == 1
    args.audio[:music] = { input: &quot;sounds/flight.ogg&quot;, looping: true }
  end

  args.state.scene ||= &quot;title&quot;

  send(&quot;#{args.state.scene}_tick&quot;, args)
end
</code></pre>
<p>Now when you start the game, the title scene will be displayed:</p>
<p><img src="./img/c11-title.jpg" alt="black text on gray background that reads 'Target Practice' with instructions on how to play" /></p>
<p>When you press the fire button, the game will start. And when you restart after game over, you'll end up back on the title scene.</p>
<h2 id="extra-credit-6"><a class="header" href="#extra-credit-6">Extra Credit</a></h2>
<ul>
<li>Display a label with the current high score in the title scene so players know what to aim for</li>
<li>Display the dragon sprite in the title scene to give a player a taste of what they can expect</li>
<li>How could you make it so that the music doesn't start until gameplay starts? Or play different music during the title scene?</li>
<li>Restarting the game back on the title scene may not be ideal. How would you change it so that restarting the game automatically goes to the <code>gameplay</code> scene?</li>
<li>Allow players to pause the game while in the middle of the gameplay scene</li>
</ul>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>We've now got three scenes in our game and can easily switch between them. The code for each scene is contained within its own method, making it easier to change a given scene without accidentally changing the others. Adding another scene to our game, like a pause menu, wouldn't be very complicated.</p>
<h2 id="whats-next-10"><a class="header" href="#whats-next-10">What's Next</a></h2>
<p>For all intents and purposes our game is done! You can start it, play it, replay it, and we've got a title scene. All that's left to do is release it so that the world (or at the very least our friends) can play it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ship-it"><a class="header" href="#ship-it">Ship It!</a></h1>
<p>So far you've been playing the debug development build of your game within the DragonRuby GTK engine. In order to get it to friends, we'll need to build versions for other players to use. We'll use the <code>dragonruby-publish</code> tool that comes with the engine to do so.</p>
<p>Releasing your game is a process that has only gotten easier and easier over time. One of the coolest things about DragonRuby GTK is that you can build your game for the web, Linux, Windows, and MacOS with one command. No matter what device (within reason) your friends have, your game will work on their computer.</p>
<p>We'll release <em>Target Practice</em> on <a href="https://itch.io/">itch.io</a>, an open marketplace for distributing your game. You can share your games for free on itch or sell them. The html version will even be able to be played in the browser. So go ahead and sign up for an itch account.</p>
<h2 id="prep-for-release"><a class="header" href="#prep-for-release">Prep for Release</a></h2>
<p>While the code of our game is done, we need to specify some info about the game, like its title and our information.</p>
<p>First, delete <code>mygame/high-score.txt</code>. We don't want our high-score from building the game to get released with the game we build to share.</p>
<p>In <code>mygame/metadata/</code> you find a file called <code>game_metadata.txt</code>. Open that up and specify the following values:</p>
<pre><code class="language-ruby">devid=youritchusername
devtitle=Your Name
gameid=targetpractice
gametitle=Target Practice
version=0.1
icon=metadata/icon.png
</code></pre>
<p>Replace <code>devid</code> and <code>devtitle</code> with your username and name. The <code>version</code> is a value you can change as you're working on your game. It lets you and your players know which version they've got in case they're running an old build without the latest changes.</p>
<p>How you version your game is up to you, but I generally think about it like this:</p>
<ul>
<li>The structure is <code>MAJOR.MINOR</code>.</li>
<li>While your game is actively being developed and isn't done, increase the minor number to the right of the <code>.</code> with each release, so <code>0.1</code>, <code>0.2</code>, and so on. Minor versions can go as high as you want, <code>0.24</code> or however many releases you have.</li>
<li>When your game is done, increase the major version on the left of the <code>.</code> to 1, so it'd be version <code>1.0</code>.</li>
<li>As you fix bugs and expand upon it after initial release, increase the number to the right, so <code>1.1</code>, <code>1.2</code>, and so on.</li>
<li>If you ever majorly overhauled your game‚Äîrewrote a lot of the code or the systems, you might want to consider bumping the major version to <code>2.0</code>.</li>
</ul>
<p>If your eyes are glazing over at this versioning stuff, don't sweat it. It's something may be more useful to you in time, but it may also not be useful to you at all.</p>
<p>You'll also see that there's a <code>mygame/metadata/icon.png</code> file. The default DragonRuby logo is fine, but if you ever wanted a custom icon, you could swap that out with your own image. That's what'll be displayed as the application icon when people run your game. </p>
<h2 id="publish-your-game"><a class="header" href="#publish-your-game">Publish Your Game</a></h2>
<p>DragonRuby GTK makes it really easy to build your game for the web and the major operating systems and publish it right on itch.</p>
<p>Open a new terminal. If you're using Visual Studio Code, there's an option to do so right within it. Don't be frightened by the terminal, we'll just be running a simple command to build our game for all of our platforms.</p>
<pre><code class="language-console">./dragonruby-publish --only-package
</code></pre>
<p>That command will build your game for all platforms DragonRuby GTK can target. Check out the <code>builds/</code> folder. You'll see all sorts of files that are your game builds.</p>
<p>Depending on what operating system your computer is using, you can even launch and play the release version of your game. On Linux, open <code>targetpractice-linux-amd64.bin</code>. On MacOS, open <code>targetpractice-mac-0.1/Target Practice.app</code>. On Windows, launch <code>targetpractice-windows-amd64.exe</code>.</p>
<h2 id="upload-to-itch"><a class="header" href="#upload-to-itch">Upload to itch</a></h2>
<p>Go to your <a href="https://itch.io/dashboard">itch Dashboard</a> and tap the &quot;Create new project&quot; button.</p>
<p>Fill out the details for your game. Be sure to write a description, add screenshots, and more. If you want your game to be played in the browser, set the type to HTML. But the most important part is that you upload your game.</p>
<img alt="itch upload screenshot with button to upload files" src="./img/c12-itch-upload.jpg" style="max-width: 380px; width: 100%;" />
<p>Tap &quot;Upload files&quot; and select the zips of the game for all of the platforms you want to upload it for. For <code>targetpractice-html5.zip</code>, check the &quot;This file will be played in the browser&quot; box, as itch will use that to determine what to make playable. For the other platforms, choose the proper OS for each file. Be sure to set the web embed size to 1280 pixels wide and 720 pixels tall so it renders at the proper size.</p>
<p>If you make changes to your game, you can upload new versions to itch automatically by running <code>./dragonruby-publish mygame</code> without having to upload them through the web browser.</p>
<p>Save your game on Itch and then view it. You'll see it download and run your game by displaying the splash screen:</p>
<p><img src="./img/c12-itch-web.jpg" alt="Target Practice splash screen" /></p>
<p>Your game isn't published yet, and that's a good thing. Only you can see it for now. If you want to share an early build with a friend, you can get a secret URL to send. Or go back to editing your game and set the <strong>Visibility &amp; access</strong> to be public to launch it.</p>
<h2 id="you-shipped-a-game"><a class="header" href="#you-shipped-a-game">You Shipped a Game!</a></h2>
<p>Can you believe it? That's awesome! You've got a game you can share with your friends and keep making more awesome.</p>
<p>Congratulations, and nice work on sticking through the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outro"><a class="header" href="#outro">Outro</a></h1>
<p>Thank you so much for reading and going through <em>Building Games with DragonRuby</em>. I hope you continue to use DragonRuby Game Toolkit and make awesome games. <a href="https://discord.dragonruby.org">Jump in the Discord</a>, and share what you've made. The community would love to see it and will happily answer any questions you have.</p>
<h2 id="make-target-practice-your-own"><a class="header" href="#make-target-practice-your-own">Make <em>Target Practice</em> Your Own</a></h2>
<p>We made <em>Target Practice</em> together, and now it's time for you to make it your own. How can you change or expand upon it? What would take it to the next level? What would make it more fun?</p>
<p>Here are some ideas for what you could do to put your personal stamp on it:</p>
<ul>
<li>Make the targets move</li>
<li>Make the targets shoot fireballs that you have to dodge</li>
<li>Replace the sprites with your own</li>
<li>Make your own music track and drop it in</li>
<li>Build out waves of enemies that fly in and attack you</li>
<li>Make it so the dragon can fly around a level instead of stay in one screen</li>
<li>Add a narrative introduction</li>
</ul>
<h2 id="say-thanks"><a class="header" href="#say-thanks">Say Thanks</a></h2>
<p>Say thanks in <a href="https://discord.dragonruby.org">the DragonRuby Discord</a> or on <a href="https://mastodon.gamedev.place/@brettmakesgames">Mastodon</a>. It would mean so much to me know that you've read the book. The website version of this book has no tracking. My success metric isn't number of views. I'll only be able to measure the success of this book through community and connecting. Share what you've made!</p>
<p>If you really want to say thanks, <a href="https://www.buymeacoffee.com/brettchalupa">buy me a coffee</a> by sending me a small tip. Financial support means the world and helps me continue to make free resources like <em>Building Games with DragonRuby</em>.</p>
<h2 id="want-more"><a class="header" href="#want-more">Want More?</a></h2>
<p>Writing a book about making games is challenging to scope properly because games are so complex. We built a pretty simple game that covered a lot of the core concepts of making games, but there are <em>so</em> many directions a sequel could head in.</p>
<p>A second edition of the book could deep dive into making a shmup with enemy waves and bosses. Or we could build an entirely different game, like a platformer or a dungeon crawler. I'd also love to write about more advanced programming topics like encapsulating behavior with classes and sharing behavior with modules. It'd be great to over adapting a game for iOS and Android too.</p>
<p>But I <em>need</em> to be sure people want a follow up book where we build a more complex game using DragonRuby Game Toolkit. Let me know if you'd like to see a sequel in <a href="https://discord.dragonruby.org">Discord</a>.</p>
<h2 id="extra-credit-7"><a class="header" href="#extra-credit-7">Extra Credit</a></h2>
<p>You'll find bonus chapters after this outro. They're one-off deep dives into specific topics, from the mindset that's required to make games to how to back up your game's source code. Check them out and see what you can learn!</p>
<h2 id="gratitude"><a class="header" href="#gratitude">Gratitude</a></h2>
<p>A big thank you to the DragonRuby community. This book would not have been possible without their support and guidance. </p>
<p>In particular, in alphabetical order, thank you to:</p>
<ul>
<li>Akzidenz for feedback and support</li>
<li>Amir for encouraging me to write this book &amp; making DragonRuby</li>
<li>Levi for nitpicking</li>
<li><a href="https://twitter.com/MobyPixel">Nick Culbertson</a> for the dragon sprite included with DRGTK</li>
<li>Owen for corrections</li>
<li>Pineapple for Discord feedback</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ruby-primer"><a class="header" href="#ruby-primer">Ruby Primer</a></h1>
<p>New to Ruby? Here's a brief walkthrough of the common language features and syntax as a quick reference.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<p>When working with Ruby, we've got some core data types to work with.</p>
<p>Strings, numbers, arrays, hashes, and booleans.</p>
<pre><code class="language-ruby">greeting = &quot;Hello, my name is Francis the Dragon.&quot;
age = 583
favorite_foods = [&quot;apples&quot;, &quot;cookies&quot;]
address = {
  line1: &quot;123 Sky Way&quot;,
  line2: &quot;Apt 2&quot;,
  state: &quot;New Dragon&quot;,
  zip: &quot;12345&quot;,
}
hungry = true
</code></pre>
<h2 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h2>
<p>Insert a value into a string using <code>#{}</code>:</p>
<pre><code class="language-ruby">&quot;My favorite foods are: #{favorite_foods.join}&quot;
</code></pre>
<h2 id="print-to-the-console"><a class="header" href="#print-to-the-console">Print to the Console</a></h2>
<p>This will write to stdout and the DragonRuby console:</p>
<pre><code class="language-ruby">puts &quot;anything&quot;
</code></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p>If you have an array, a hash, or any object that collects data, you can loop through their values with <code>#each</code>.</p>
<pre><code class="language-ruby">favorite_foods.each do |food|
  puts(food)
end

address.each do |key, value|
  puts(&quot;#{key}: #{value}&quot;)
end
</code></pre>
<h2 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h2>
<pre><code class="language-ruby">if monday? || tuesday?
  puts &quot;not fun days&quot;
elsif wednesday? || thursday?
  puts &quot;fine day&quot;
else
  puts &quot;great days&quot;
end
</code></pre>
<p><code>&amp;&amp;</code> - AND</p>
<p><code>||</code> - OR</p>
<h2 id="methods--return-values"><a class="header" href="#methods--return-values">Methods &amp; Return Values</a></h2>
<p>Define a method:</p>
<pre><code class="language-ruby">def add(num1, num2)
  num1 + num2
end
</code></pre>
<p>Ruby implicitly returns the last expression in method and by default returns <code>nil</code> if there's no expression.</p>
<p>You can explicitly return a value with <code>return</code>:</p>
<pre><code class="language-ruby">def add(num1, num2)
  return num1 + num2
end
</code></pre>
<p>Explicit returns are mostly used when you want to exit a method early.</p>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p>Blocks are chunks of Ruby code that yield to the caller. At first you'll use blocks when calling specific methods, like <code>#each</code>, but it can be useful to write your own blocks as well.</p>
<p><a href="https://www.youtube.com/watch?v=1YjSP-cEzMo">üì∫ Ruby Blocks Explained</a></p>
<h2 id="nil"><a class="header" href="#nil">nil</a></h2>
<p><code>nil</code> in Ruby is known as <code>null</code> in other languages. It's the absence of a value.</p>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>When something goes wrong in Ruby, an exception is thrown. You can rescue from exceptions using the <code>rescue</code> keyword:</p>
<pre><code class="language-ruby">begin
  # do_some_things
rescue SomeError =&gt; e
  puts e
end
</code></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://www.ruby-lang.org/en/documentation/quickstart/">Ruby in Twenty Minutes</a></li>
<li><a href="https://poignant.guide/">why's (poignant) guide to Ruby</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beyond-the-code"><a class="header" href="#beyond-the-code">Beyond the Code</a></h1>
<p>This book is focused on how to program a  simple game using DragonRuby Game Toolkit. It briefly touches upon game design, sound, and art, but there‚Äôs a lot more to making games than coding them.</p>
<p>This Extra Credit chapter goes over the mindset to keep when making games and how to study the games you play. The more games you make, the better you‚Äôll get it. That sounds obvious, but it lets you off the hook for making basic games at the beginning.</p>
<h2 id="start-small"><a class="header" href="#start-small">Start Small</a></h2>
<p>When you‚Äôre just starting out in any creative endeavor, set your sights on small projects that you can realistically finish. It‚Äôs easy to want to try to make a big game that‚Äôs like your favorites, but if you were starting out with creative writing, you‚Äôd start by writing short stories, not an epic novel. Why? Because you don‚Äôt have the stamina and skills yet to write a novel or make a huge game. Sure, a select few can work on their first game or novel for years and finish it and have some success. But it‚Äôs more likely than not that you‚Äôll abandon your project due to challenges and lost interest.</p>
<h2 id="what-can-you-cut"><a class="header" href="#what-can-you-cut">What Can You Cut?</a></h2>
<p>When you have an idea for a game, ask yourself what you can cut from it while still maintaining the core essence of it. Don‚Äôt dwell on adding a bunch of complex systems. Focus on the fun and how you can subtract to bring that forward. Arcade games do a great job of making short, replayable, minimal experiences.</p>
<h2 id="finish-your-games"><a class="header" href="#finish-your-games">Finish Your Games</a></h2>
<p>When making your small games, finish them! Finishing what you start is so important. Having a bunch of unreleased prototypes isn‚Äôt fun for anyone. It‚Äôs okay to share works in progress and tiny games. Finish what you make and release it. Shipping games is a muscle and different skill set than building the game. The more practice you get, the better off you‚Äôll be when it comes time to ship.</p>
<h2 id="release-them-for-free"><a class="header" href="#release-them-for-free">Release Them for Free</a></h2>
<p>Release your games for free for a while. Don‚Äôt put the pressure on yourself of making a commercial project when you‚Äôre just starting out. Your goal should be to build an audience of fans who enjoy your game. Make that barrier as low as possible by releasing your game for the web and the major operating systems. And release them for free. Would you rather make and release a free game 1000 people play or a paid game that only 5 people play? It‚Äôs defeating to release a paid game no one buys. Also, your first games won‚Äôt be very good. That‚Äôs okay! No one who starts playing the guitar is very good right at the beginning. The only way to get better is to suck at first and keep working at it. Getting your games in people‚Äôs hands and getting feedback is much more important than trying to make money. Once you‚Äôve shipped a bunch of small games, you‚Äôll have gained new skills and confidence. You‚Äôll also be grounded in reality and not be fantasizing about selling millions of copies of your idea. Make and release small, humble games.</p>
<h2 id="dont-worry-about-being-original"><a class="header" href="#dont-worry-about-being-original">Don't Worry About Being Original</a></h2>
<p>When you‚Äôre making your small, free games, don‚Äôt worry about being original. That may sound like blasphemy, but the best way to learn is to copy mechanics and systems from your favorite games to learn. You‚Äôll inevitably infuse your own sensibilities into them and make something unique. When we learn an instrument, we play covers of our favorite songs and that‚Äôs encouraged. What would it be like to ‚Äúcover‚Äù your favorite game? Originality will come with time when the ideas are flowing and don‚Äôt agree with how other games do something.</p>
<h2 id="do-game-jams"><a class="header" href="#do-game-jams">Do Game Jams</a></h2>
<p>Game jams are constrainted events where people make games within a certain timeframe, sometimes with specific rules. They're a great way to start and finish a game in a short period of time. You can experiment and take risks and connect with the community of your fellow participants. I can't recommend them enough. Try to do at least one jam a year (or more if your heart desires).</p>
<p><a href="https://itch.io/jams">Itch has a directory of jams</a> and <a href="https://ludumdare.com/">Ludum Dare is a long-running jam with many participants</a>.</p>
<h2 id="share-your-work"><a class="header" href="#share-your-work">Share Your Work</a></h2>
<p>Share your work. Whether on a YouTube channel, blog, or social network. Post screenshots. Share what you learn. Talk about what worked and what didn‚Äôt. Help other game developers. Don‚Äôt think about it as marketing, even though it is. Be genuine and share your progress. </p>
<h2 id="study-what-you-play"><a class="header" href="#study-what-you-play">Study What You Play</a></h2>
<p>If you‚Äôre interested in making games, it‚Äôs likely you enjoy playing them. When you‚Äôre playing games, think about how they work. From the systems to the menu design to how the UI is structured. What do you like? What can‚Äôt you stand? How would you make something similar? Take notes and intentionally think about the games you‚Äôre playing. Incorporate the aspects you love into the games you make and discard what you can stand.</p>
<h2 id="find-a-community"><a class="header" href="#find-a-community">Find a Community</a></h2>
<p>Find a community of developers making similar caliber games. Whether it‚Äôs a Discord or in-person meet up group, surround yourself with people making games who have similar goals to you. Support and push each other. Play each others‚Äô games and learn from one another. You may even find collaborators among the community with difference strengths that you can leverage to make an even better game. </p>
<h2 id="pace-yourself"><a class="header" href="#pace-yourself">Pace Yourself</a></h2>
<p>It‚Äôs important to take breaks. Pace yourself! If you love games and are enjoying making them, think about what it'd be like to make games for the next 40 years of your life instead of just the next 4 months. What would you do differently to sustain yourself?</p>
<p>Being a game developer requires determination and passion, but it also requires a lot of self-care. ‚ù§Ô∏è</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dragonruby-game-toolkit-resources"><a class="header" href="#dragonruby-game-toolkit-resources">DragonRuby Game Toolkit Resources</a></h1>
<p>What follows is a directory of useful resources for continuing your journey with DragonRuby Game Toolkit.</p>
<ul>
<li><a href="https://dragonruby.org/toolkit/game">DragonRuby Game Toolkit website</a></li>
<li><a href="https://docs.dragonruby.org">DragonRuby Game Toolkit docs</a></li>
<li><a href="https://discord.dragonruby.org">Community Discord</a></li>
<li><a href="https://www.dragonriders.community/recipes">Dragon Riders Community Recipes</a> ‚Äî solutions to common needs when building games with DragonRuby GTK</li>
<li><a href="https://www.dragonriders.community/awesome-dragonruby/">Awesome DragonRuby</a> ‚Äî community-curated list of resources</li>
<li><a href="https://dragonrubydispatch.com/">DragonRuby Newsletter</a></li>
<li><a href="https://dev.to/presidentbeef/api-levels-in-dragonruby-game-toolkit-4jb4">Justin Collins (a.k.a. presidentbeef)'s DragonRuby blog series</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-dev-resources"><a class="header" href="#game-dev-resources">Game Dev Resources</a></h1>
<p>While this book covers the technical aspects of programming games with Ruby, there is a lot more to making games than just coding. This bonus chapter includes resources and information to help you make your games your own.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<p>Tools for making games that I recommend. Centered around on 2D games, like the book is.</p>
<h3 id="audio"><a class="header" href="#audio">Audio</a></h3>
<ul>
<li><a href="https://sfxr.me/">jsfxr</a> ‚Äî generate sound effects</li>
<li><a href="https://www.audacityteam.org/">Audacity</a> ‚Äî audio editor</li>
<li><a href="https://1bitdragon.com/">1BitDragon</a> ‚Äî intuitive music creation software</li>
</ul>
<h3 id="graphics"><a class="header" href="#graphics">Graphics</a></h3>
<ul>
<li><a href="https://www.aseprite.org/">Aseprite</a> ‚Äî pixel art tool</li>
<li><a href="https://krita.org/en/">Krita</a> ‚Äî digital painting tool</li>
</ul>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>Making a game by yourself can seem like a lot when you need to design the game, code it, make the art, create music, and then release it. Luckily there are lots of generous game devs out there who share their assets, from music to sound effects to sprites to 3D models. Whether you're rapidly prototyping and will redo the art later or don't want to deal with it at all, you might be surprised at the great assets out there.</p>
<ul>
<li><a href="https://opengameart.org/">OpenGameArt.org</a></li>
<li><a href="https://itch.io/game-assets">Assets on Itch</a></li>
</ul>
<h2 id="books"><a class="header" href="#books">Books</a></h2>
<p>I love reading books about making games. It's a great way to take a break from the computer but still learn about the hobby you love. Here are some of my favorites.</p>
<ul>
<li><a href="https://bossfightbooks.com/products/spelunky-by-derek-yu">Spelunky by Derek Yu</a> ‚Äî deep-dive into the game development process by the creator of the game himself</li>
<li><a href="https://www.valadria.com/how-to-make-a-video-game-all-by-yourself/">How to Make a Video Game All By Yourself</a> ‚Äî excellent book on being a solo game dev</li>
<li><a href="https://wireframe.raspberrypi.com/books/code-the-classics1">Code the Classics</a> ‚Äî free book covering how to make classic games in PyGame, but if you instead used DragonRuby GTK?</li>
<li><a href="https://www.amazon.com/Indie-Games-Delivery-Don-Daglow/dp/0996781552">Indie Games: From Dream to Delivery</a> ‚Äî a book of questions and essays to get your brain churning about your game for when you're further a long</li>
</ul>
<h2 id="videos"><a class="header" href="#videos">Videos</a></h2>
<p>A selection of the best videos about making games:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=Fy0aCDmgnxg">&quot;Juice it or lose it&quot; presentation</a> ‚Äî how to polish games</li>
<li><a href="https://www.youtube.com/watch?v=AJdEqssNZ-U">&quot;The art of screenshake&quot; presentation</a> ‚Äî¬†step-by-step guide on making a game feel good to play</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-control"><a class="header" href="#source-control">Source Control</a></h1>
<p>When working on any piece of software, whether it's a video game or an app to track how many dogs you pet in a given day, it's extremely important to keep track of the changes to your code and keep it backed up in a secure location.</p>
<p>Imagine this scenario: you work on your game for three months. It's amazing. It's your X-Files Dating Sim. You've painstakingly drawn all of the characters, written the scenario, coded up all the interactions. Then one day your computer gets stolen by a giant crow! I don't trust those crows, I never have. Suddenly your game is gone, poof. All that hard work just sitting on a hard-drive barely being protected by the shell of your laptop from the aggressive pecks of the entire local union of crows.</p>
<p>You'd just have to start over, from scratch. That is if you aren't too bummed out about losing the entire game. Crow theft--it's the number one reason to back up your game's source code.</p>
<h2 id="back-up-your-game"><a class="header" href="#back-up-your-game">Back Up Your Game</a></h2>
<p>You could use a cloud service like Dropbox to back it up to the ‚ú®cloud‚ú®. That's better than nothing. Then when you get a new computer because, you know, the crows stole your other one, you'll be good to go. Your game will be backed up. Heck, Dropbox does it automatically. That's pretty nifty.</p>
<h2 id="using-git"><a class="header" href="#using-git">Using Git</a></h2>
<p>I'd like to advocate for using source control (a.k.a. version control) to keep track of the changes to your game. It's like a more advanced form of using a cloud storage provider. The primary source control tool is called <a href="https://git-scm.com/">Git</a>. Git lets you track your changes by creating commits--references of what changed and why since the last time you made a commit.</p>
<p>The basics of Git are beyond the scope of this book, but there are some helpful resources out there:</p>
<ul>
<li><a href="https://git-scm.com/doc">Git's Documentation</a></li>
<li><a href="https://github.com/git-guides">GitHub's Git Guide</a></li>
<li><a href="https://git-scm.com/downloads/guis">GUI apps for working with Git</a></li>
</ul>
<p>Using version control at first may seem a bit tedious, but it's immensely valuable. Not only can you document why you made a change to help your future self and others, but you can safely experiment without fear of really messing things up. Because you're tracking the changes to your game's source, if you go down a rabbithole that doesn't work out, you can easily undo it. Let's explore some examples of commits and scenarios where it's helpful.</p>
<p>Any time you add a feature, create a commit. This lets you see your game evolve over time. Let's say you added player input with the gamepad. Boom, make a commit! Let's say you improved the enemy AI, commit that. Keep your commits small. Don't make hundreds of lines of unrelated changes and make a big commit that just say &quot;changed some stuff&quot;. You're trying to help yourself but creating a useful log of your game. Here's a look at commits from a little project of mine:</p>
<pre><code class="language-console">commit 9a74acdbec6971fab76fd81b2d78526ffef2c621
Date:   Thu Nov 24 07:22:15 2022 -0500

    Add score tracking

commit c5c277eae786100609b7dfbc9a516e44b705f59b
Date:   Thu Nov 24 07:16:24 2022 -0500

    add bullet &amp; enemy collision

commit 35aba8938b0e1afd7888ca09f6693330307facb6
Date:   Thu Nov 24 06:59:45 2022 -0500

    Rename project

commit 357b0412b24d805f49a1c542564ec76fe2962b7a
Date:   Thu Nov 24 06:59:25 2022 -0500

    Delete dead enemies from collection

commit 967fd73886e298394c1f923280bbdfb7f7cfa778
Date:   Thu Nov 24 06:53:27 2022 -0500

    swap player &amp; enemy sprite; revise bullet sprite

commit 2a233f7248d03cd8c602158acd9b1899b3ee8429
Date:   Wed Nov 23 23:04:46 2022 -0500

    add simple bullet firing
</code></pre>
<p>Any time I add, change, or fix functionality, I make a commit. This lets me easily see my changes.</p>
<p>The flow of development is:</p>
<ol>
<li>Write code to make the game do something</li>
<li>Test the changes out in the game</li>
<li>Adjust the code</li>
<li>Test the adjustments</li>
<li>Create a commit</li>
</ol>
<p>Start the flow again!</p>
<h2 id="source-code-hosts"><a class="header" href="#source-code-hosts">Source Code Hosts</a></h2>
<p>When you use Git on your computer for your project, you're creating a log of changes that exists in your computer. You'll want to push your Git repository up to a host so that it's backed up. There are many free hosts out there, allowing you to create private or public repositories of your code. </p>
<p>Some popular ones are:</p>
<ul>
<li><a href="https://github.com">GitHub</a></li>
<li><a href="https://bitbucket.org/">Bitbucket</a></li>
<li><a href="https://about.gitlab.com/">GitLab</a></li>
</ul>
<p>In the flow of development above, step 6 is: push the code to the remote host. This ensures those pesky crows can't totally steal your game and you'll live to code another day.</p>
<h2 id="using-source-control-with-dragonruby-game-toolkit"><a class="header" href="#using-source-control-with-dragonruby-game-toolkit">Using Source Control with DragonRuby Game Toolkit</a></h2>
<p>When I work on my DRGTK games, I check the entire project, including the engine, into source control. This lets me easily clone and run the project without needing to set anything up. Because the engine binary (<code>./dragonruby</code>) is so small, it's no problem at all. I'll often clean out the sample code and sprites if I'm not going to use them.</p>
<p>A benefit to this is that if a new version of DRGTK is released, I can create its own commit for that and easily rollback if anything breaks. Phew!</p>
<h2 id="a-note-on-open-source-dragonruby-game-toolkit-games"><a class="header" href="#a-note-on-open-source-dragonruby-game-toolkit-games">A Note on Open Source DragonRuby Game Toolkit Games</a></h2>
<p>You may have heard of the term open source software (OSS). It's when people write code and release available to the public to see and use under varying license terms. Code is released as open source for a variety of reasons, from helping people learn to collaborating with anyone. It allows people to contribute and help fix things. This book is even <a href="https://github.com/DragonRidersUnite/book">open source</a>!</p>
<p>The DragonRuby Game Toolkit is not open source software, which means that you can't distribute the engine publicly on a source control host, but you can publish the code you've written, since it's your code. This is a bit a nuanced situation with DRGTK because of how projects work.</p>
<p>I recommended checking the entire folder of the engine and your game into source control in the previous section. But if you want to open source your game, I'd do it a little differently. And it helps to know this from the start of your project, but it's okay if you do it later down the line.</p>
<p>If you want to open source you game, follow these steps:</p>
<ol>
<li>Unzip the engine</li>
<li>Change into the <code>mygame</code> directory</li>
<li>Initialize your Git repository there with <code>git init</code></li>
<li>Don't track the engine parent folder</li>
</ol>
<p>The downside to this approach is that you need to ensure you keep your specific engine version parent directory available. You could use version control to sync that and then use Git to publish it online as open source code.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<ul>
<li>Back up your games! You never know when you might lose your computer.</li>
<li>Source control, like Git, let's you make changes with confidence.</li>
<li>Push your code regularly to a source control host so that it's backed up.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
