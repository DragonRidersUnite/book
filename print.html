<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Games with DragonRuby</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A comprehensive guide to shipping cross-platform 2D games with ease using DragonRuby Game Toolkit.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="01-hello-dragon.html"><strong aria-hidden="true">1.</strong> Hello Dragon!</a></li><li class="chapter-item expanded "><a href="02-player-movement.html"><strong aria-hidden="true">2.</strong> Player Movement</a></li><li class="chapter-item expanded "><a href="03-spit-fire.html"><strong aria-hidden="true">3.</strong> Spit Fire</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Drawing Shapes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Animations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Enemies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Hitboxes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Refactor Break!</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Life &amp; Death</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Basic AI</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Waves of Enemies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Bullet Patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Scenes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Boss Fight</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Juice</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Sound Effects</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Music</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> Screenshake</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.4.</strong> Menus</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.5.</strong> Metadata</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Ship Your Game</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> What Next</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><div>Ruby Primer</div></li><li class="chapter-item expanded affix "><a href="source-control.html">Source Control</a></li><li class="chapter-item expanded affix "><a href="game-dev-resources.html">Game Dev Resources</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Building Games with DragonRuby</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/DragonRidersUnite/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="./img/cover.webp" alt="cover of Building Games with DragonRuby, with the subtitle 'A comprehensive guide to shipping cross-platform games with ease' by Brett Chalupa and the Dragon Rider Community." /></p>
<p>üöß <em>Building Games with DragonRuby</em> is a work in progress. Expect typos, issues, and incompleteness. üöß</p>
<p>This book is aimed at new game developers who are interested in learning to code and build games. If you've written code before, especially Ruby, then you'll have a bit of a headstart. But the concepts in this book are beginner friendly. Whether you're new to game dev or just DragonRuby Game Toolkit, you'll have made a finished game by the end of this.</p>
<p>You need no prior experience with programming or game making to follow this book.</p>
<h2 id="why-learn-how-to-make-games"><a class="header" href="#why-learn-how-to-make-games">Why Learn How to Make Games</a></h2>
<p>Making games is a total blast. It's challenging but rewarding. They're the sum total of so many creative mediums, <em>plus</em> they're interactive. You'll learn so many different skills by making games:</p>
<ul>
<li>Programming and logic</li>
<li>Rendering images</li>
<li>Responding to input</li>
<li>Game design</li>
<li>Interactive design</li>
<li>Working with image files</li>
<li>Editing audio files</li>
<li>Distributing the game software to users</li>
<li>Getting feedback from your game and iterating</li>
</ul>
<h2 id="about-dragonruby-game-toolkit"><a class="header" href="#about-dragonruby-game-toolkit">About DragonRuby Game Toolkit</a></h2>
<p><a href="https://dragonruby.org/toolkit/game">DragonRuby Game Toolkit</a> (DRGTK) is a cross-platform game engine for building 2D games. It lets you write games in Ruby, a wonderfully expressive and approachable language. It allows game developers to quickly iterate on their games and ship them to any modern platform.</p>
<p>DRGTK is <strong>not</strong> a no-code engine. You'll write the code that your game runs. This may seem scary at first, but it's a lot of fun and really powerful. Making games is also a great way to learn how to code! Don't know Ruby? That's okay, this book will teach you what you need to know.</p>
<h3 id="but-it-isnt-free"><a class="header" href="#but-it-isnt-free">But it isn't free!</a></h3>
<p>DRGTK costs money, yes. And there are plenty of free game engines out there. But the DRGTK team is committed to sustainably working on the engine and making it the best it can be, which means they need to get paid for their work. Support small teams by buying their software, it shows you're interested and it helps them keep doing what they love.</p>
<p>You're investing in the engine and ecosystem, quite literally, by buying DRGTK. I want to see it succeed, so I bought a license. I want to see it succeed so badly I've written this book to try to help <em>you</em> make games with it.</p>
<p>Plus, if you're a student or in need of financial assistance, the DragonRuby team offers free licenses. <a href="https://dragonruby.org/toolkit/game">Get in touch with the team to get a free license.</a></p>
<h2 id="why-dragonruby-toolkit"><a class="header" href="#why-dragonruby-toolkit">Why DragonRuby Toolkit</a></h2>
<p>There are more game engines, frameworks, and libraries than I can count on my hands and toes. So why should you use DragonRuby?</p>
<p>That's a legit question. Here are my reasons why:</p>
<ul>
<li>It's focused on 2D games, so there's no competing interests in how the tooling works. It means what you need to know is pretty simple and easy to remember.</li>
<li>It allows building games for all modern platforms, from desktop computers to the web to mobile devices to consoles. It's truly cross-platform and <em>just works</em>, which is amazing.</li>
<li>It's fast a heck, which is important for making quality games.</li>
<li>It makes use of Ruby, which is a wonderfully productive programming language.</li>
<li>It doesn't force you to use a specific editor or tooling.</li>
<li>It's lightweight to run the engine, which is great. Everything runs fast.</li>
<li>It has live-reload and no compile times, which means when you change your game code, it automatically refreshes in the running engine. This is honestly so amazing, that you wouldn't know it unless you've used other game engines that require you to start a new build with each change.</li>
</ul>
<p>I'm going to be honest, DRGTK might not be for you. If you want to make 3D games, look elsewhere. Although, if you're new to game development, I wouldn't recommend starting with a 3D game. If you're absolutely not willing to try coding, look elsewhere.</p>
<p>But for everyone else, I think DRGTK will knock your socks off (or at least shift them down a little).</p>
<h2 id="mindset"><a class="header" href="#mindset">Mindset</a></h2>
<p>When learning something new, especially something that's challenging, it's important to have the right mindset.</p>
<ul>
<li>Be curious: it's the best way to learn!</li>
<li>Be patient: learning is difficult, but stick with it</li>
<li>Be kind: to yourself and others</li>
</ul>
<p>When we learn how to play a new instrument, we learn the basics by covering simplistic pieces of music. Similarly, we're going to &quot;cover&quot; simpler game mechanics to get you started. Before long, you'll grasp the basics and be able to move onto more complex games and mechanics.</p>
<p>Start by making small games that you can finish in a couple of days. Make a lot of small games to learn quickly. Don't get too wrapped up in your dream idea or making something that gets on Steam. Definitely don't try to make an MMORPG. Instead, focus on <strong>shipping</strong> your small games.</p>
<p>What's shipping? Isn't that when you want Mulder and Scully to kiss? No! Get your head out of the gutter you alien-loving freak. (I want to believe! üõ∏) Shipping is when you 1. finish your game and 2. release it for people to play it.</p>
<p>So here's your mindset, really, boiled down: make a small game and ship it for free, then make another small game and ship it for free. Before long, you'll be building a visual novel where Mulder and Scully kiss and be swimming in a pool of cryptocoins! But seriously, what that mindset will do is help you grow as a developer, build an audience, and get your shipping muscle primed and ready for making a better game with each one.</p>
<h2 id="what-well-be-making"><a class="header" href="#what-well-be-making">What We'll Be Making</a></h2>
<p>Throughout the book, we'll be building a simple shoot-'em-up where you pilot a dragon. You'll learn all of the foundation aspects of making a game:</p>
<ul>
<li>The game loop</li>
<li>Rendering text</li>
<li>Rendering sprites and animating them</li>
<li>Handling input</li>
<li>Enemies and AI</li>
<li>Playing sound effects and music</li>
<li>Polishing your game</li>
<li>Shipping it!</li>
</ul>
<p>TODO: playable demo link</p>
<h2 id="hold-the-gosh-dang-phone"><a class="header" href="#hold-the-gosh-dang-phone">Hold the Gosh Dang Phone</a></h2>
<p>&quot;Who the heck are <em>you</em>?&quot; you might be shouting at your screen. Little ole me? I'm just the voice of the dragon that lives within all beings! No, no, I kid. I'm Brett! I'm a programmer who enjoys making games and sharing what I've learned along the way.</p>
<p><img src="./img/brett.png" alt="pixel avatar of Brett" /></p>
<p>That's-a-me! If I was a bunch of pixels I guess.</p>
<p>I love Ruby. I've been writing it for over 12 years, and it's such a joy. I also love games. Particularly 2D games. So here we are. ‚ù§Ô∏èüíé + üéÆ = üìï How's that for an equation?!</p>
<p>I don't know, you want me to be serious about why you should listen to me? Oh you skipped this section, okay fine. Wow, did you drop that banana peel there? You trying to take me out already? This early in the book? Well, I'll see you in the next chapter! We'll see who gets the last laugh.</p>
<h2 id="contribute"><a class="header" href="#contribute">Contribute</a></h2>
<p>This book is open source. That means anyone can view the code that builds it and contribute toward making better. Did you find something that doesn't work, a typo, or lacks clarity? <a href="https://github.com/DragonRidersUnite/book">Submit an issue or contribute on GitHub.</a> It's easy and you can do it right from your browser. Thanks in advance!</p>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<p>All right, are you ready to make a game? Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-dragon"><a class="header" href="#hello-dragon">Hello Dragon!</a></h1>
<p>We'll start by rendering an image and some simple text on the screen. But first, we need to get our computer and DragonRuby Game Toolkit ready for developing.</p>
<h2 id="first-steps"><a class="header" href="#first-steps">First Steps</a></h2>
<ol>
<li><strong>Download a code editor:</strong> Since you'll be coding your game, you need a special text editor to let you write the code without any extra formatting that text editors like Microsoft Word add. <a href="https://code.visualstudio.com/">Visual Studio Code</a> is a great free editor. Download and install it. (Or use your own favorite editor.)</li>
<li><strong>Get DragonRuby GTK:</strong> You need to get a copy of DragonRuby GTK so you can use the engine. <a href="https://dragonruby.itch.io/dragonruby-gtk/purchase">Buy it on Itch and download the zip file for your operating system.</a></li>
<li><strong>Extract the DRGTK engine zip</strong>: In your computer's file explorer, extract the engine zip file.</li>
</ol>
<p>You're ready to work on your game. Let's get to it!</p>
<p><strong>ProTip:</strong> don't delete the zip file! You can unzip it again for when you start working on your next game. It's helpful to keep it around.</p>
<h2 id="whats-in-the-engine-zip"><a class="header" href="#whats-in-the-engine-zip">What's in the Engine Zip</a></h2>
<p>When you download DragonRuby Game Toolkit, it contains everything you need to build your game. There's no external dependencies to install or monkey with. You just use the provided files and start making your game.</p>
<p>Let's go over the key files in the archive you just extracted:</p>
<ul>
<li><code>dragonruby</code> ‚Äî the executable you'll run to launch your game in development mode, you're primary entry into the development flow</li>
<li><code>dragonruby-publish</code> ‚Äî a command-line tool to help you easily build and publish your game online, don't worry about this yet!</li>
<li><code>samples/</code> ‚Äî a folder of example code that you can run if you'd like, or just ignore it for now</li>
<li><code>docs/</code> ‚Äî the DragonRuby Game Toolkit docs for the version you've downloaded, extremely handy if you want to dive deeper than this book</li>
<li><code>mygame/</code> üåü ‚Äî as the name implies, this is where the code, graphics, sound, and other assets live for your game; this is the primary folder you'll be working in
<ul>
<li><code>app/</code> ‚Äî this is where your Ruby code goes
<ul>
<li><code>main.rb</code> ‚Äî this is the main file for your game code, don't worry about the other two yet</li>
</ul>
</li>
<li><code>data/</code> ‚Äî where you can put any data for your game, like level editor files</li>
<li><code>fonts/</code> ‚Äî where fonts go, duh!</li>
<li><code>metadata/</code> ‚Äî configuration files for your game, we'll do more here later</li>
<li><code>sounds/</code> ‚Äî where music and sound effects go</li>
<li><code>sprites/</code> ‚Äî where images go that will be rendered in the game; there are already some simple ones to work with by default</li>
</ul>
</li>
</ul>
<p>Don't worry about the other files yet. Focus on the <code>mygame/</code> directory, and, specifically, <code>mygame/app/main.rb</code>.</p>
<h2 id="start-the-game"><a class="header" href="#start-the-game">Start the Game</a></h2>
<p>Launch the <code>dragonruby</code> file.</p>
<p>If you're on MacOS, right-click the file and select &quot;Open&quot;. You'll need to ensure software from unverified sources can be installed.</p>
<p>Here's what gets displayed:</p>
<p><img src="./img/hello-world.webp" alt="screenshot of the Hello World! for DragonRuby GTK" /></p>
<p>This isn't a game... yet! But it is doing three key things:</p>
<ol>
<li>Launching an app window</li>
<li>Rendering text</li>
<li>Displaying an image</li>
</ol>
<p>And you haven't even written any code yet. Not a bad starting place.</p>
<p>DRGTK handles the unfun stuff of making games‚Äîdealing with low-level APIs like graphics, window, and sounds. We can instead focus on making our game.</p>
<h2 id="an-overview-of-the-main-game-file"><a class="header" href="#an-overview-of-the-main-game-file">An Overview of the Main Game File</a></h2>
<p>Let's take a look at what's in <code>mygame/app/main.rb</code>:</p>
<pre><code class="language-ruby">def tick args
  args.outputs.labels  &lt;&lt; [640, 500, 'Hello World!', 5, 1]
  args.outputs.labels  &lt;&lt; [640, 460, 'Go to docs/docs.html and read it!', 5, 1]
  args.outputs.labels  &lt;&lt; [640, 420, 'Join the Discord! https://discord.dragonruby.org', 5, 1]
  args.outputs.sprites &lt;&lt; [576, 280, 128, 101, 'dragonruby.png']
end
</code></pre>
<p>You can open this file yourself in Visual Studio Code. Go ahead and do that: New Window &gt; Open &gt; [select the folder on your computer with the engine in it]</p>
<p>Six lines of codes to render text and an image? Not bad! (Trust me, if you did this all from scratch without an engine, it'd take at least hundreds of lines of code.)</p>
<p>Here's what that code does, line by line:</p>
<pre><code class="language-ruby">def tick args
</code></pre>
<p>This <code>def</code>ines a method called <code>tick</code> and passes in an argument called <code>args</code>. Methods are reusable pieces of code that you can call to do something over and over again. Think of methods like verbs; they're actions. Methods are a foundational building block of code that allow for code reuse.</p>
<p>Let's say you wanted to give a friend a cookie üç™, you'd define a method called <code>give_cookie</code> and pass in the <code>friend</code> as a parameter.</p>
<pre><code class="language-ruby">def give_cookie(friend)
  friend.eat(:cookie)
end
</code></pre>
<p>You'd then call that method like:</p>
<pre><code class="language-ruby">francis = Friend.new
give_cookie(francis)
</code></pre>
<p>Wait, how'd we get talking about cookies and friends? Okay, back to the code above.</p>
<p><code>args</code> is a bunch of data that gets passed into <code>tick</code> whenver it is called. We'll learn more about <code>args</code> soon.</p>
<p>The next three lines handle outputting text to the screen:</p>
<pre><code class="language-ruby">args.outputs.labels  &lt;&lt; [640, 500, 'Hello World!', 5, 1]
args.outputs.labels  &lt;&lt; [640, 460, 'Go to docs/docs.html and read it!', 5, 1]
args.outputs.labels  &lt;&lt; [640, 420, 'Join the Discord! https://discord.dragonruby.org', 5, 1]
</code></pre>
<p>Your eyes might be melting a little bit. But don't worry, wipe that melted bit of eye away and focus! It's actually pretty intuitive once you get the hang of it.</p>
<p>Remember <code>args</code> from above? That parameter that's passed into <code>tick</code>? Well, you can call methods on it! This allows you to interact with the game engine.</p>
<p><code>args</code> has a method called <code>outputs</code> that represents the data that gets rendered in the screen. You access it with <code>args.outputs</code>. Neato! <code>labels</code> is a method on <code>outputs</code>, see how the <code>.</code> chains things together?</p>
<p>The <code>&lt;&lt;</code> is called the shovel operator. It lets you push data into a collection. <code>labels</code> is the collection we're shoveling data into because we want to render some text.</p>
<p>And then finally the code within the brackets <code>[]</code> is an array of data that represents what we want to display on the screen. It may not be clear exactly what it's doing yet, but it'll become more clear over time.</p>
<p>[TODO: array illustration]</p>
<p>You can see some code in quotes, those are strings. And they're what's being displayed by the game. In order to show the text, though, we need to tell the engine where to place it on the screen. That's what the first two elements of the array do: they specify the x and y position in of the text in the game. Then there's the text we want to render. That's followed by the size. Then finally the alignment (centered in this case).</p>
<p>Here's it broken down:</p>
<pre><code class="language-ruby">#  x,   y,           text, size, alignment
[640, 500, 'Hello World!',    5,         1]
</code></pre>
<p>Don't worry about memorizing what the positional elements of the array mean. This is just a quick way to render text. We'll start using a more friendly approach soon enough. The sample game does this three times, thus rendering three difference pieces of text. The <code>y</code> coordinate is different for each, stacking them on top of each other vertically instead of overlapping one another.</p>
<p>Gosh enough of this rambling, let's adjust some code. Change the text from <code>&quot;Hello World!&quot;</code> to be <code>&quot;Hello Dragon!&quot;</code> and save the file.</p>
<p><img src="./img/hello-dragon.webp" alt="screenshot of the Hello Dragon! for DragonRuby GTK" /></p>
<p>Did you see that? The game reloaded your code and changed the text to be &quot;Hello Dragon!&quot; That was quick, wasn't it? That's one of the best parts of DRGTK‚Äîlive reloading of your game code in the engine. This allows you to make changes to your game quickly, reducing the time between the cycles of writing your code and testing it.</p>
<pre><code class="language-ruby">args.outputs.sprites &lt;&lt; [576, 280, 128, 101, 'dragonruby.png']
</code></pre>
<p><code>args.outputs.sprites</code> is like labels, but it's instead a collection for sprites. It renders the <code>&quot;dragonruby.png&quot;</code> image at x: 576, y: 280, just like label text, but it also sets the size of the image to display. That's what the <code>128</code> and <code>101</code> represent in the array. Here's a break down of those elements:</p>
<pre><code class="language-ruby">#  x,   y,   w,   h,            image
[576, 280, 128, 101, 'dragonruby.png']
</code></pre>
<p>Just like with labels, don't worry about memorizing the order here. There are friendlier ways to display them that we'll get to shortly.</p>
<p>But it's an easy enough bit of code for putting an image on the screen.</p>
<p>Finally, the last line:</p>
<pre><code class="language-ruby">end
</code></pre>
<p>signifies that the definition of the <code>tick</code> method is over. Any code after that isn't part of the <code>tick</code> method. That's it for what we get out of the box.</p>
<h2 id="screen-coordinates-explained"><a class="header" href="#screen-coordinates-explained">Screen Coordinates Explained</a></h2>
<p>Let's take a detour down Screen Coordinates Road. The <code>x</code> and <code>y</code> position are coordinates on the two-dimensional plane of the game window. Remember geometry? I barely do. But this is important, so don't doze off on me yet, we're only in the first chapter still!</p>
<p>[TODO: coordinates illustration]</p>
<p>DRGTK games are made up of a window that's 1280x720 pixels large. That's 1280 pixels wide and 720 pixels tall. The rectangle of the game screen is 921600 pixels, that's those two numbers multiplied. Each of those pixels has a coordinate on the plane. It makes it easy to refer to a specific pixel by using its <code>x</code> and <code>y</code> position.</p>
<p>DRGTK starts 0, 0 in the lower left. So 1280, 720 would be the upper right. <strong>Note:</strong> this varies from most game engines and libraries and tools, but it's intentional to make it easier to think about gravity and the geometric 2D plane that is taught in mathematics.</p>
<p>It's important to keep coordinates in mind, as we'll be using them a lot when making our game. A major aspect of games is moving things on the screen, which we do by changing their coordinates on the plane.</p>
<h2 id="our-own-hello"><a class="header" href="#our-own-hello">Our Own Hello</a></h2>
<p>Back to making the game. Okay, yeah, you changed a string and it changed what was rendered. That's neat. But let's bump it up a notch.</p>
<p>I want you to delete the code in <code>mygame/app/main.rb</code>. Select it all and delete it. Yup, I know, the blank canvas is a challenge. But you need to start writing the code yourself in order to learn and build the muscle memory. So go ahead and type out each line below into your <code>main.rb</code>.</p>
<p>[TODO: hand-write it, don't copy it illustration]</p>
<pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; [120, 120, &quot;Hello Dragon!&quot;]
end
</code></pre>
<p>You know what that does, right? Well you saw it automatically reload in your game, so of course you do!</p>
<p>Let's greet our friend Oboe too.</p>
<pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; [120, 120, &quot;Hello Dragon!&quot;]
  args.outputs.labels &lt;&lt; [120, 100, &quot;Hello Oboe!&quot;]
end
</code></pre>
<p>Wow, so many friends we're saying hello to! The thing is... that code is a bit... duplicative. Let's write our own method to clean that up:</p>
<pre><code class="language-ruby">def greet friend
  &quot;Hello #{friend}!&quot;
end

def tick args
  args.outputs.labels &lt;&lt; [120, 120, greet(&quot;Dragon&quot;)]
  args.outputs.labels &lt;&lt; [120, 100, greet(&quot;Oboe&quot;)]
end
</code></pre>
<p>The new code refactors (changes the implementation of the code without changing the behavior) the original so that we can easily change the greeting in one place instead of many. This is a bit of a trivial example, but it shows how we can write our own methods in DRGTK to make our code better. Reusing code is foundational for the rest of this book.</p>
<p>The <code>&quot;Hello #{friend}!&quot;</code> code does what's called string interpolation. It takes whatever <code>friend</code> is, hopefully a name as a string, and inserts it. It's pretty similar to this code: <code>&quot;Hello &quot; + friend + &quot;!&quot;</code>, but quite a bit friendlier to use. The <code>#{}</code> tells Ruby to run any Ruby code within those curly braces.</p>
<p>Methods in Ruby return a value. Return values can then be used by the caller for whatever purposes are needed. In the example above, the return value is the string we build. Ruby returns the last line of the method definition automatically. But you can explicitly return early with <code>return</code>, which can be useful if you want to end the execution of a method early.</p>
<p>Go ahead and change the <code>#greet</code> method to:</p>
<pre><code class="language-ruby">def greet friend
  &quot;Hello #{friend}!&quot;
  1
end
</code></pre>
<p>Whoa! What happened to our greetings? Well, we changed our code and it now always returns <code>1</code>, which isn't what we want. It's just an example to illustrate how that works. Go ahead and undo that change.</p>
<p>Let's do one final thing in our hand-crafted, artisinal version of rendering text and images. Let's display a sprite. In <code>mygame/sprites/misc/</code> there's a file named <code>dragon-0.png</code>. It's a pixel art dragon made by Nick Culbertson that's free to use. Pretty neat!</p>
<pre><code class="language-ruby">def greet friend
  &quot;Hello #{friend}!&quot;
end

def tick args
  args.outputs.labels &lt;&lt; [120, 120, greet(&quot;Dragon&quot;)]
  args.outputs.labels &lt;&lt; [120, 100, greet(&quot;Oboe&quot;)]
  # Here's our new line
  args.outputs.sprites &lt;&lt; [120, 280, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p><img src="./img/hello-dragon-own.webp" alt="screenshot of the Hello Dragon! with pixel dragon displayed" /></p>
<p>That's some pretty fine code for the first chapter. We've got text and an image displaying. We learned about methods too. Don't worry if it's not all making total and complete sense. You'll understand more with time. Remember, be patient.</p>
<h2 id="game-loop-explained"><a class="header" href="#game-loop-explained">Game Loop Explained</a></h2>
<p>There's a lot of magic happening where we can just write <code>def tick</code> and magically have a game. What's happening here is that DragonRuby Game Toolkit takes the code in <code>mygame/app/main.rb</code>, find the tick method, and then runs a loop that calls it 60 times every second until the program closes. This loop is referred to as the Game Loop.</p>
<p>When programming games, any number of things are happening at one time. Enemies are moving, images are being displayed, math is being calculated, input is being handled. The loop runs over and over again, accounting for any changes in the state of the game. This is similar to how screens on devices work‚Äîthey refresh so many times a second, so fast that it's barely perceptible to the human eye.</p>
<p>Within the game loop, we'll keep track of everything that's happening, update state, and render text and images. It's important to begin to think about things in a loop, as it influences timing and code structure.</p>
<p>[TODO: drawing of the game loop and why it matters]</p>
<p>The game loop will begin to feel more natural over time, but for now, remember this: <strong>DRGTK runs the <code>tick</code> method 60 times every second</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="player-movement"><a class="header" href="#player-movement">Player Movement</a></h1>
<p>In the last chapter, we got a dragon sprite showing up on the screen and some text. Let's build upon that by making it so we can control the dragon with our keyboard and a gamepad. Because guess what? That dragon is now the main character of this game we're building. üêâ Buckle up, it's dragon riding time.</p>
<p>Simplify <code>mygame/app/main.rb</code> to be just this for now:</p>
<pre><code class="language-ruby">def tick args
  args.outputs.sprites &lt;&lt; [120, 280, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>That displays our player dragon and nothing else. Excellent. Let's get this dragon moving!</p>
<p>In order to handle moving the player, we need to keep track of the position across the game loops. This lets us know where the player was last <code>tick</code>, check if they should move, and then update the position accordingly.</p>
<p>Update your <code>mygame/app/main.rb</code> to be this:</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>There are a couple of new things here:</p>
<ul>
<li><code>args.state</code></li>
<li><code>||=</code></li>
</ul>
<p>Let's start with <code>args.state</code>. It's basically a blob that can be anything you want it to be, a bit like Kirby. Feed it <code>player_x</code> and it keeps track of it. Whatever you feed the <code>args.state</code>, it'll be accessible in future ticks. Keeping track of game state across ticks is important! It's part of the game loop. If we don't know where the player last was, how can we calculate where they should move to? We need to keep track of it in someplace. <code>args.state</code> is a fine place to start.</p>
<p>You can define anything on <code>args.state</code>, so it's up to you to use useful names. You could make <code>args.state.bleh</code> and set it to your favorite color, <code>args.state.bleh = &quot;blue&quot;</code> or your age, <code>args.state.age = 30</code>. Much like Kirby, <code>args.state</code> doesn't care what you feed it. It's just hungry for your data.</p>
<p>In this case, we're feeding it <code>||= 120</code>. What the heck is <code>||=</code>? Well... Maybe we need to start with <code>=</code>. You might read that as &quot;equals&quot; but it's actually the assignment operator. It means: set the thing on the left to the value on the right. It's a core programming concept. It's useful for assigning data to properties that we want to keep track of.</p>
<pre><code class="language-ruby">name = &quot;Francis&quot;
</code></pre>
<p>That code assigns the string Francis to the variable name. Then we can use <code>name</code> to refer to that value. It may not seem useful quite yet, but it will soon enough.</p>
<p>You could then use that variable like this:</p>
<pre><code class="language-ruby">puts name
</code></pre>
<p>That calls a the <code>puts</code> method and passes our argument <code>name</code> to it. It prints whatever the value is out to the console. If you put that in your game code and press <kbd>~</kbd> to open the console, you'll see it print <code>&quot;Francis&quot;</code> a bunch.</p>
<p><code>||=</code> in English is &quot;or equals&quot;. That code above, <code>args.state.player_x ||= 120</code> would be read as: assign the property <code>player_x</code> on <code>args.state</code> the numeric value of 120 unless it's alreay assigned a value.</p>
<p>Remember how tick is running once every 60 seconds? We don't want to always set <code>args.state.player_x</code> to <code>120</code>. We just want to set it to that initially and then we'll update that value when we press keys on our keyboard or buttons on our gamepad. We haven't done that yet, but that's what's next.</p>
<p>Wow! That was a lot of explaination for two measly lines of code. But I'm telling ya', they're two really important lines of code when it comes to game programming.</p>
<p>Then, finally, we change the <code>x</code> and <code>y</code> value for the dragon sprite to be the value stored in <code>args.state</code> so that we can actually make use of that value instead of our hard-coded position before.</p>
<h2 id="checking-for-input"><a class="header" href="#checking-for-input">Checking for Input</a></h2>
<p>In <code>tick</code> we'll check to see if a given input is pressed. If it is, we'll change the sprite's x and y position accordingly.</p>
<p>Our ole buddy <code>args</code> has a little something known as <code>args.inputs</code>. This lets us check... inputs! Isn't programming nice? Most of the time the words used in programming make sense. But some of the time, they really don't, and it's a gosh dang nightmare. But let's commit right here, right now to trying to name things in a way that's useful. Okay, you're committed. When you name a method <code>def thingy</code>, you'll remember this. And your ears will ring a little bit and your eyes will get just a little dry and you'll remember that you broke this commitment.</p>
<p>Let's make use of <code>args.inputs</code>:</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280

  if args.inputs.left
    args.state.player_x -= 10
  elsif args.inputs.right
    args.state.player_x += 10
  end

  if args.inputs.up
    args.state.player_y += 10
  elsif args.inputs.down
    args.state.player_y -= 10
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>You can now control the dragon with WASD, the arrow keys, or your controller. Pretty neat! It's almost fun. All it took was 10 lines of code. Let's break them down.</p>
<pre><code class="language-ruby">if args.inputs.left
  args.state.player_x -= 10
elsif args.inputs.right
  args.state.player_x += 10
end
</code></pre>
<p>This section checks for horizontal movement. If the left input is pressed, reduce the player's x position by 10 pixels. <code>-=</code> means, subtract the value on the right from the value on the left. It's the same as <code>args.state.player_x = args.state.player_x - 10</code>, but it's much more concise. We increase <code>player_x</code> to move right, decrease it to move left.</p>
<p><code>if</code> and <code>elsif</code> are conditional checks. The code only runs if the value is true (more specifically, truthy, but let's not worry about that yet).</p>
<pre><code class="language-ruby">if args.inputs.up
  args.state.player_y += 10
elsif args.inputs.down
  args.state.player_y -= 10
end
</code></pre>
<p>Then we check for vertical movement. We add to <code>player_y</code> to move up, decrease it to move down.</p>
<p>What if we wanted our dragon to move faster though? We could change those four instances of <code>10</code> to be <code>12</code> and see how that feels, sure. But that's annoying to update it all over. Let's make use of a variable! We'll call it <code>speed</code>:</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  speed = 10

  if args.inputs.left
    args.state.player_x -= speed
  elsif args.inputs.right
    args.state.player_x += speed
  end

  if args.inputs.up
    args.state.player_y += speed
  elsif args.inputs.down
    args.state.player_y -= speed
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, 100, 80, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>Whoa! We just refactored that code. It's easier to change (ETC) now, which is a sign we're improving things.</p>
<h2 id="boundaries"><a class="header" href="#boundaries">Boundaries</a></h2>
<p>You can move your dragon completely off the screen, lost in the great unknown! This isn't ideal. Let's make it so our little buddy can't leave the bounds of the screen.</p>
<p>[TODO: drawing about boundaries]</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  speed = 12
  player_w = 100
  player_h = 80

  if args.inputs.left
    args.state.player_x -= speed
  elsif args.inputs.right
    args.state.player_x += speed
  end

  if args.inputs.up
    args.state.player_y += speed
  elsif args.inputs.down
    args.state.player_y -= speed
  end

  if args.state.player_x +  player_w &gt; args.grid.w
    args.state.player_x = args.grid.w - player_w
  end

  if args.state.player_x &lt; 0
    args.state.player_x = 0
  end

  if args.state.player_y + player_h &gt; args.grid.h
    args.state.player_y = args.grid.h - player_h
  end

  if args.state.player_y &lt; 0
    args.state.player_y = 0
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, player_w, player_h, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>Our dragon won't leave the screen. Woot woot! We've got some serious code here! Look at that logic. Here's what changed:</p>
<p>We moved the width and height of the player into variables so that they're easier to reference and reuse. Boom. We need those to do some math on the boundaries too. There's a general programming idea out there known as Don't Repeat Yourself (DRY). As soon as you have a piece of code, especially a number, that represents a value and is used multiple times, put it in a variable. This makes its intent clear as to what it represents and makes it easier to change. Win-win.</p>
<p>Here's the good stuff. We check the boundary for the x axis:</p>
<pre><code class="language-ruby">  if args.state.player_x +  player_w &gt; args.grid.w
    args.state.player_x = args.grid.w - player_w
  end

  if args.state.player_x &lt; 0
    args.state.player_x = 0
  end
</code></pre>
<p>We check the right side of the screen: if the current player's x position plus their width is greater than <code>args.grid.w</code>, then we set the x position to the width of the screen (<code>args.grid.w</code>) minus the width of the sprite. For example, if we move the sprite so it has the x position of 1284, 4 pixels past the right edge of the screen, we override that change and set it to 1280 minus the player's width.</p>
<p>It's so important that this happens after checking for input. You don't want to change <code>args.state.player_x</code> after this check, otherwise the boundary won't be enforced. Order matters with the code we write within <code>tick</code>.</p>
<p><code>args.grid.w</code> is the width of the screen. It's always 1280, but we don't want to have that magic number in our code. So we use <code>args.grid.w</code>.</p>
<p>Next we check the left side of the screen: if the player's x is less than 0, then we set it to zero. That's a bit similar to the right side, just simpler.</p>
<p>Then we do the same thing for the top and bottom of the screen by checking the y position.</p>
<h2 id="extra-credit"><a class="header" href="#extra-credit">Extra Credit</a></h2>
<ul>
<li>When you move the dragon horizontally and vertically at the same time, the dragon moves twice as fast. How could you make it so the dragon moves at a uniform speed still when that happens?</li>
</ul>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next</a></h2>
<p>In the next chapter we'll make our dragon spit fireballs when we press a key or button. Watch out!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spit-fire"><a class="header" href="#spit-fire">Spit Fire</a></h1>
<p>Our next mission is to make our dragon spit fire because that's just what they do. We'll piece this whole thing into a game with a narrative and intentional design soon enough. But let's keep focusing on simple mechanics and code for right now.</p>
<h2 id="player-refactor"><a class="header" href="#player-refactor">Player Refactor</a></h2>
<p>In the code from the last chapter, there's a lot of code related to the player, from handling their input to moving them, to displaying the sprite. See how we have so much state with the <code>player_</code> prefix? That's a sign we can probably refactor the code to make it a bit easier to manage.</p>
<pre><code class="language-ruby">def tick args
  args.state.player_x ||= 120
  args.state.player_y ||= 280
  speed = 12
  player_w = 100
  player_h = 80

  if args.inputs.left
    args.state.player_x -= speed
  elsif args.inputs.right
    args.state.player_x += speed
  end

  if args.inputs.up
    args.state.player_y += speed
  elsif args.inputs.down
    args.state.player_y -= speed
  end

  if args.state.player_x +  player_w &gt; args.grid.w
    args.state.player_x = args.grid.w - player_w
  end

  if args.state.player_x &lt; 0
    args.state.player_x = 0
  end

  if args.state.player_y + player_h &gt; args.grid.h
    args.state.player_y = args.grid.h - player_h
  end

  if args.state.player_y &lt; 0
    args.state.player_y = 0
  end

  args.outputs.sprites &lt;&lt; [args.state.player_x, args.state.player_y, player_w, player_h, 'sprites/misc/dragon-0.png']
end
</code></pre>
<p>Let's change our <code>app/main.rb</code> to now be this instead:</p>
<pre><code class="language-ruby"># TODO: test this works
class Player
  def initialize
    @x = 120
    @y = 280
    @speed = 12
    @w = 100
    @h = 80
  end

  def tick args
    if args.inputs.left
      @x -= @speed
    elsif args.inputs.right
      @x += @speed
    end

    if args.inputs.up
      @y += @speed
    elsif args.inputs.down
      @y -= @speed
    end

    if @x + @w &gt; args.grid.w
      @x = args.grid.w - @w
    end

    if @x &lt; 0
      @x = 0
    end

    if @y + @h &gt; args.grid.h
      @y = args.grid.h - @h
    end

    if @y &lt; 0
      @y = 0
    end

    args.outputs.sprites &lt;&lt; [@x, @y, @w, @h, 'sprites/misc/dragon-0.png']
  end
end

def tick args
  args.state.player ||= Player.new
  args.state.player.tick args
end
</code></pre>
<p>We've once again changed the code without changing the behavior of the game. This iterative approach to game development and programming is <em>so</em> important. It gives you permission to do something quickly to experiment and then take time to make things better. With this refactor, we've made the code easier to manage and reason about.</p>
<p>The <code>class Player</code> line defines what's known as a class. Many programming languages have classes, and they usually represnet nouns (things) that have properties and can take some actions. Classes have instances, which is one given case of it. You know how there are birds out there in the world? Bird is the concept of the animal--it's a classification (class). But if there was a bird sitting on your head, thats an instance of given bird. And the bird sitting on the powerline across the road watching your every move is another instance of a bird. If we wanted to represent birds in our game, we could define a class:</p>
<pre><code class="language-ruby">class Bird
  def evil?
    true
  end
end
</code></pre>
<p>That lets you create new birds with <code>Bird.new</code> and then check if they are evil (which they always are). For example:</p>
<pre><code class="language-ruby">bird1 = Bird.new
bird1.evil? # =&gt; true
bird2 = Bird.new
bird2.evil? # =&gt; true
</code></pre>
<p>You can have multiple instances of a class. But for our <code>Player</code> dragon, we'll just have one.</p>
<p>The <code>def initialize</code> line defines a method that's called whenever we create a new instance of <code>Player</code>. This is known as the constructor, and it's always called <code>initialize</code> in Ruby. Here you can set variables and write code that gets run once upon creation. The <code>@</code> in front of our variables makes them instance variables--variables that are available within the methods of a class instance (as the name implies). Setting these variables once and referencing them throughout the Player cleans up the code quite a bit.</p>
<p>The <code>tick</code> method that's newly defined does what our global <code>tick</code> method did before, but it contains only what's needed to be managed for the player. As we make our game more complex, encapsulating the code will make it easier to think about and change.</p>
<p>In the global <code>tick</code> method, we create a new player in the <code>args.state.player</code> if there isn't one already. And then every frame we update our player instance.</p>
<pre><code class="language-ruby">def tick args
  args.state.player ||= Player.new
  args.state.player.tick args
end
</code></pre>
<p>We'll be introducing more classes soon enough, so it's great to have one established without actually changing the functionality of the game.</p>
<h2 id="fire-on-input"><a class="header" href="#fire-on-input">Fire on Input</a></h2>
<p>[ displaying a label ]</p>
<h2 id="moving-fireballs"><a class="header" href="#moving-fireballs">Moving Fireballs</a></h2>
<h2 id="placeholder-square"><a class="header" href="#placeholder-square">Placeholder Square</a></h2>
<h2 id="tracking-fireballs"><a class="header" href="#tracking-fireballs">Tracking Fireballs</a></h2>
<h2 id="displaying-a-sprite"><a class="header" href="#displaying-a-sprite">Displaying a Sprite</a></h2>
<h2 id="cleaning-up"><a class="header" href="#cleaning-up">Cleaning Up</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-control"><a class="header" href="#source-control">Source Control</a></h1>
<p>When working on any piece of software, whether it's a video game or an app to track how dogs you pet in a given day, it's extremely important to keep track of the changes to your code and keep it backed up in a secure location.</p>
<p>Imagine this scenario: you work on your game for three months. It's amazing. It's your X-Files Dating Sim. You've painstakingly drawn all of the characters, written the scenario, coded up all the interactions. Then one day your computer gets stolen by a giant crow! I don't trust those crows, I never have. Suddenly your game is gone, poof. All that hard work just sitting on a hard-drive barely being protected by the shell of your laptop from the aggressive pecks of the entire local union of crows.</p>
<p>You'd just have to start over, from scratch. That is if you aren't too bummed out about losing the entire game. Crow theft--it's the number one reason to back up your game's source code.</p>
<h2 id="back-up-your-game"><a class="header" href="#back-up-your-game">Back Up Your Game</a></h2>
<p>You could use a cloud service like Dropbox to back it up to the ‚ú®cloud‚ú®. That's better than nothing. Then when you get a new computer because, you know, the crows stole your other one, you'll be good to go. Your game will be backed up. Heck, Dropbox does it automatically. That's pretty nifty.</p>
<h2 id="using-git"><a class="header" href="#using-git">Using Git</a></h2>
<p>I'd like to advocate for using source control (a.k.a. version control) to keep track of the changes to your game. It's like a more advanced form of using a cloud storage provider. The primary source control tool is called <a href="https://git-scm.com/">Git</a>. Git lets you track your changes by creating commits--references of what changed and why since the last time you made a commit.</p>
<p>The basics of Git are beyond the scope of this book, but there are some helpful resources out there:</p>
<ul>
<li><a href="https://git-scm.com/doc">Git's Documentation</a></li>
<li><a href="https://github.com/git-guides">GitHub's Git Guide</a></li>
<li><a href="https://git-scm.com/downloads/guis">GUI apps for working with Git</a></li>
</ul>
<p>Using version control at first may seem a bit tedious, but it's immensely valuable. Not only can you document why you made a change to help your future self and others, but you can safely experiment without fear of really messing things up. Because you're tracking the changes to your game's source, if you go down a rabbithole that doesn't work out, you can easily undo it. Let's explore some examples of commits and scenarios where it's helpful.</p>
<p>Any time you add a feature, create a commit. This lets you see your game evolve over time. Let's say you added player input with the gamepad. Boom, make a commit! Let's say you improved the enemy AI, commit that. Keep your commits small. Don't make hundreds of lines of unrelated changes and make a big commit that just say &quot;changed some stuff&quot;. You're trying to help yourself but creating a useful log of your game. Here's a look at commits from a little project of mine:</p>
<pre><code class="language-console">commit 9a74acdbec6971fab76fd81b2d78526ffef2c621
Date:   Thu Nov 24 07:22:15 2022 -0500

    Add score tracking

commit c5c277eae786100609b7dfbc9a516e44b705f59b
Date:   Thu Nov 24 07:16:24 2022 -0500

    add bullet &amp; enemy collision

commit 35aba8938b0e1afd7888ca09f6693330307facb6
Date:   Thu Nov 24 06:59:45 2022 -0500

    Rename project

commit 357b0412b24d805f49a1c542564ec76fe2962b7a
Date:   Thu Nov 24 06:59:25 2022 -0500

    Delete dead enemies from collection

commit 967fd73886e298394c1f923280bbdfb7f7cfa778
Date:   Thu Nov 24 06:53:27 2022 -0500

    swap player &amp; enemy sprite; revise bullet sprite

commit 2a233f7248d03cd8c602158acd9b1899b3ee8429
Date:   Wed Nov 23 23:04:46 2022 -0500

    add simple bullet firing
</code></pre>
<p>Any time I add, change, or fix functionality, I make a commit. This lets me easily see my changes.</p>
<p>The flow of development is:</p>
<ol>
<li>Write code to make the game do something</li>
<li>Test the changes out in the game</li>
<li>Adjust the code</li>
<li>Test the adjustments</li>
<li>Create a commit</li>
</ol>
<p>Start the flow again!</p>
<h2 id="source-code-hosts"><a class="header" href="#source-code-hosts">Source Code Hosts</a></h2>
<p>When you use Git on your computer for your project, you're creating a log of changes that exists in your computer. You'll want to push your Git repository up to a host so that it's backed up. There are many free hosts out there, allowing you to create private or public repositories of your code. </p>
<p>Some popular ones are:</p>
<ul>
<li><a href="https://github.com">GitHub</a></li>
<li><a href="https://bitbucket.org/">Bitbucket</a></li>
<li><a href="https://about.gitlab.com/">GitLab</a></li>
</ul>
<p>In the flow of development above, step 6 is: push the code to the remote host. This ensures those pesky crows can't totally steal your game and you'll live to code another day.</p>
<h2 id="using-source-control-with-dragonruby-game-toolkit"><a class="header" href="#using-source-control-with-dragonruby-game-toolkit">Using Source Control with DragonRuby Game Toolkit</a></h2>
<p>When I work on my DRGTK games, I check the entire project, including the engine, into source control. This lets me easily clone and run the project without needing to set anything up. Because the engine binary (<code>./dragonruby</code>) is so small, it's no problem at all. I'll often clean out the sample code and sprites if I'm not going to use them.</p>
<p>A benefit to this is that if a new version of DRGTK is released, I can create its own commit for that and easily rollback if anything breaks. Phew!</p>
<h2 id="a-note-on-open-source-dragonruby-game-toolkit-games"><a class="header" href="#a-note-on-open-source-dragonruby-game-toolkit-games">A Note on Open Source DragonRuby Game Toolkit Games</a></h2>
<p>You may have heard of the term open source software (OSS). It's when people write code and release available to the public to see and use under varying license terms. Code is released as open source for a variety of reasons, from helping people learn to collaborating with anyone. It allows people to contribute and help fix things. This book is even <a href="https://github.com/DragonRidersUnite/book">open source</a>!</p>
<p>The DragonRuby Game Toolkit is not open source software, which means that you can't distribute the engine publicly on a source control host, but you can publish the code you've written, since it's your code. This is a bit a nuanced situation with DRGTK because of how projects work.</p>
<p>I recommended checking the entire folder of the engine and your game into source control in the previous section. But if you want to open source your game, I'd do it a little differently. And it helps to know this from the start of your project, but it's okay if you do it later down the line.</p>
<p>If you want to open source you game, follow these steps:</p>
<ol>
<li>Unzip the engine</li>
<li>Change into the <code>mygame</code> directory</li>
<li>Initialize your Git repository there with <code>git init</code></li>
<li>Don't track the engine parent folder</li>
</ol>
<p>The downside to this approach is that you need to ensure you keep your specific engine version parent directory available. You could use version control to sync that and then use Git to publish it online as open source code.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Back up your games! You never know when you might lose your computer.</li>
<li>Source control, like Git, let's you make changes with confidence.</li>
<li>Push your code regularly to a source control host so that it's backed up.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-dev-resources"><a class="header" href="#game-dev-resources">Game Dev Resources</a></h1>
<p>While this book covers the technical aspects of programming games with Ruby, there is a lot more to making games than just coding. This bonus chapter includes resources and information to help you make your games your own.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<h3 id="audio"><a class="header" href="#audio">Audio</a></h3>
<ul>
<li>Sfxr</li>
<li>Audacity</li>
<li>1BitDragon</li>
</ul>
<h3 id="graphics"><a class="header" href="#graphics">Graphics</a></h3>
<ul>
<li>Aseprite</li>
</ul>
<h2 id="game-design"><a class="header" href="#game-design">Game Design</a></h2>
<ul>
<li>Juice video</li>
<li>jw game feel vid</li>
</ul>
<h2 id="books"><a class="header" href="#books">Books</a></h2>
<ul>
<li>How To Make a Game By Yourself</li>
<li>From Dream to Delivery</li>
<li>Spelunky book</li>
</ul>
<h2 id="youtube-videos"><a class="header" href="#youtube-videos">YouTube Videos</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
